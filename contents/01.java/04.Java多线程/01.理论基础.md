# 理论基础
::: tip
本文主要对 Java 多线程 理论基础 的基本情况进行总结。@Frank Zhao
:::
## 本章目录
[[toc]]
## 为什么需要多线程
CPU、内存、I/O 设备的速度是有极大差异的，为了合理利用 CPU 的高性能，平衡这三者的速度差异，<br>
计算机体系结构、操作系统、编译程序都做出了贡献，主要体现为:<br>
* CPU 增加了缓存，以均衡与内存的速度差异；
   * 弊端： 导致 可见性 问题 
* 操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异；
   * 弊端： 导致 原子性 问题 
* 编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。
   * 弊端： 导致 有序性 问题
## 多线程不安全的三要素
### 可见性
由 CPU缓存 引起 <br>
举个简单的例子，看下面这段代码：<br>
``` java
// 线程1执行的代码
int i = 0;
i = 10;

// 线程2执行的代码
j = i;
```
假若执行线程1的是CPU1，执行线程2的是CPU2。<br>
当线程1执行 i = 10 这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，<br>
那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。 <br>
此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，<br>
注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10。 <br>
这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。 <br>
::: danger
一个线程对共享变量的修改，另外一个线程必须能够立刻看到。
:::
### 原子性
由 分时复用 引起 <br>
经典的转账问题：比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。 <br>
试想一下，如果这2个操作不具备原子性，会造成什么样的后果。<br>
假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。<br>
这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。 <br>
所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。<br>
::: danger
一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
:::
### 有序性
由 重排序 引起 <br>
举个简单的例子，看下面这段代码：<br>
``` java
int i = 0;              
boolean flag = false;
i = 1;                // 语句1  
flag = true;          // 语句2
```
上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。<br>
从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗? <br>
不一定，为什么呢? 这里可能会发生指令重排序。<br>
在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。
重排序分三种类型： 
* 编译器优化的重排序。
   * 编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。 
* 指令级并行的重排序。
   * 现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。
   * 如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。 
* 内存系统的重排序。
   * 由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

<br>
从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：<br><br>
<img src="/images/java/java-jmm-3.png" width="50%" height="50%" />
<br>
上述的 1 属于编译器重排序，2 和 3 属于处理器重排序。<br>
这些重排序都可能会导致多线程程序出现内存可见性问题。<br>
对于编译器，JMM 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。<br>
对于处理器重排序，JMM 的处理器重排序规则会要求 java 编译器在生成指令序列时，<br>
插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，<br>
通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。<br>

::: danger
程序执行的顺序按照代码的先后顺序执行。
:::
### 线程不安全示例
::: details 代码实例解析
``` java
package com.escco.test;

public class Test {
    public static void main(String[] args) {
        ThreadUnsafeExample threadUnsafeExample = new ThreadUnsafeExample();
        class MyRunnable implements Runnable {
            public void run() {
                threadUnsafeExample.pay();
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                threadUnsafeExample.add();
                System.out.println(threadUnsafeExample.get());
            }
        }
        MyRunnable runnable = new MyRunnable();
        Thread t1 = new Thread(runnable);
        Thread t2 = new Thread(runnable);
        Thread t3 = new Thread(runnable);
        t1.start();
        t2.start();
        t3.start();
    }
}

class ThreadUnsafeExample {
    int cnt = 1000;

    public void add() {
        cnt = cnt + 50;
    }

    public void pay() {
        cnt = cnt - 50;
    }

    public int get() {
        return cnt;
    }
}

运行结果：
900
950
1000
```
:::
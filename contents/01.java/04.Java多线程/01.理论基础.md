# 理论基础
::: tip
本文主要对 Java 多线程 理论基础 的基本情况进行总结。@Frank Zhao
:::
## 本章目录
[[toc]]
## 为什么需要多线程
CPU、内存、I/O 设备的速度是有极大差异的，为了合理利用 CPU 的高性能，平衡这三者的速度差异，<br>
计算机体系结构、操作系统、编译程序都做出了贡献，主要体现为:<br>
* CPU 增加了缓存，以均衡与内存的速度差异；
   * 弊端： 导致 可见性 问题 
* 操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异；
   * 弊端： 导致 原子性 问题 
* 编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。
   * 弊端： 导致 有序性 问题
## 多线程不安全的三要素
### 可见性
由 CPU缓存 引起 <br>
举个简单的例子，看下面这段代码：<br>
``` java
// 线程1执行的代码
int i = 0;
i = 10;

// 线程2执行的代码
j = i;
```
假若执行线程1的是CPU1，执行线程2的是CPU2。<br>
当线程1执行 i = 10 这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，<br>
那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。 <br>
此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，<br>
注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10。 <br>
这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。 <br>
::: danger
一个线程对共享变量的修改，另外一个线程必须能够立刻看到。
:::
### 原子性
由 分时复用 引起 <br>
::: danger
一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
:::
### 有序性
由 重排序 引起 <br>
::: danger
程序执行的顺序按照代码的先后顺序执行。
:::
### 线程不安全示例
::: details 代码实例解析
``` java
```
:::
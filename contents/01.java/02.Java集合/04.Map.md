# Map
::: tip
本文主要对 Map 的基本情况进行总结。@Frank Zhao
:::
## 本章目录
[[toc]]
## Map 概述
<br><br>
<img src="/images/java/22234145t3m10.jpg" width="100%" height="100%" />
<br><br>
``` java
public interface Map<K,V> { }
```
Map 是映射接口，Map中存储的内容是键值对（key-value）。<br>
Map 映射中不能包含重复的键；每个键最多只能映射到一个值。<br>

## HashMap
HashMap 是一个散列表，它存储的内容是键值对（key-value）映射。<br>
HashMap 的实现不是同步的，这意味着它不是线程安全的。<br>
HashMap 的key、value都可以为null。<br>
HashMap 的映射不是有序的。<br>
``` java
public class HashMap<K,V> extends AbstractMap<K,V>
    implements Map<K,V>, Cloneable, Serializable
```
* Map - 表示 HashMap 是键值对结构，具备Map接口的所有功能。
* Cloneable - 表示 HashMap 覆盖了函数clone()，能被克隆。
* Serializable - 表示 HashMap 支持序列化，能通过序列化去传输。
### HashMap 继承关系
``` java
public interface Map<K,V>
  |
public abstract class AbstractMap<K,V> implements Map<K,V>
  |
public class HashMap<K,V> extends AbstractMap<K,V>
    implements Map<K,V>, Cloneable, Serializable
```
* AbstractMap 是继承于Map的抽象类，它实现了Map中的大部分API。
   * 其它Map的实现类可以通过继承AbstractMap来减少重复编码。
### HashMap 源码解析
<br>
<img src="/images/java/HashMap_base.png" width="60%" height="60%" />
<br><br>

HashMap 就是一个散列表，它是通过“拉链法”解决哈希冲突的。<br>
* HashMap 是通过"拉链法"实现的哈希表。它包括几个重要的成员变量：
   * table 是一个Entry[]数组类型，而Entry实际上就是一个单向链表。
      * 哈希表的"key-value键值对"都是存储在Entry数组中的。
   * size 是HashMap的大小，它是HashMap保存的键值对的数量。
   * threshold 是HashMap的阈值，用于判断是否需要调整HashMap的容量。
      * threshold的值="容量*加载因子"，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。
   * loadFactor 就是加载因子。
   * modCount 是用来实现 fail-fast 机制的。
* HashMap 的实例有三个参数影响其性能：“初始容量” 、“容量”和 “加载因子”。
   * 初始容量 是哈希表在创建时的容量。 												
   * 容量 是哈希表中桶的实际数量。									
   * 加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度，用来指定自动扩容的临界值
      * 当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要进行 rehash 操作（重建内部数据结构），从而哈希表将具有大约两倍的桶数。												
      * 通常，默认加载因子是 0.75，这是在时间和空间成本上寻求一种折衷。												
      * 加载因子过高虽然减少了空间开销，但同时也增加了查询成本。	
      * 在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少 rehash 操作次数。
      * 如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。
      * 对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。
* HashMap中的key-value都是存储在Entry数组中的。											
   * Entry 实际上就是一个单向链表。这也是为什么我们说HashMap是通过拉链法解决哈希冲突的。										
   * Entry 实现了Map.Entry 接口，即实现getKey(), getValue(), setValue(V value), equals(Object o), hashCode()等函数。										
   * 这些都是基本的读取/修改key、value值的函数。	
* 将对象放入到HashMap或HashSet中时，有两个方法需要特别关心:  hashCode() 和 equals() 。
   * hashCode()方法决定了对象会被放到哪个bucket里，当多个对象的哈希值冲突时，
   * equals()方法决定了这些对象是否是“同一个对象”。
   * 所以，如果要将自定义的对象放入到HashMap或HashSet中，需要指定 hashCode() 和 equals() 方法。
``` java
// 初始容量
// The default initial capacity - MUST be a power of two.
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4;
```
### HashMap 遍历方法
::: details 代码实例解析
遍历HashMap的键值对<br>
``` java
// 假设map是HashMap对象
// map中的key是String类型，value是Integer类型
Integer integ = null;
Iterator iter = map.entrySet().iterator();
while(iter.hasNext()) {
    Map.Entry entry = (Map.Entry)iter.next();
    // 获取key
    key = (String)entry.getKey();
    // 获取value
    integ = (Integer)entry.getValue();
}
```
遍历HashMap的键<br>
``` java
// 假设map是HashMap对象
// map中的key是String类型，value是Integer类型
String key = null;
Integer integ = null;
Iterator iter = map.keySet().iterator();
while (iter.hasNext()) {
    // 获取key
    key = (String)iter.next();
    // 根据key，获取value
    integ = (Integer)map.get(key);
}
```
遍历HashMap的值<br>
``` java
// 假设map是HashMap对象
// map中的key是String类型，value是Integer类型
Integer value = null;
Collection c = map.values();
Iterator iter= c.iterator();
while (iter.hasNext()) {
    value = (Integer)iter.next();
}
```
:::
### HashMap 方法说明
* get(Object key)
   * 根据指定的key值返回对应的value 	
* put(K key, V value)
   * 将指定的key, value对添加到map里。 	
* remove(Object key)
   * 删除key值对应的value 
### HashMap 实例
::: details 代码实例解析
``` java
public static void main(String[] args) {
   // 初始化随机种子
   Random r = new Random();
   // 新建HashMap
   HashMap map = new HashMap();
   // 添加操作
   map.put("one", r.nextInt(10));
   map.put("two", r.nextInt(10));
   map.put("three", r.nextInt(10));

   // 打印出map
   System.out.println("map:"+map);

   // 通过Iterator遍历key-value
   Iterator iter = map.entrySet().iterator();
   while(iter.hasNext()) {
      Map.Entry entry = (Map.Entry)iter.next();
      System.out.println("next : "+ entry.getKey() +" - "+entry.getValue());
   }

   // HashMap的键值对个数
   System.out.println("size:"+map.size());

   // containsKey(Object key) :是否包含键key
   System.out.println("contains key two : "+map.containsKey("two"));
   System.out.println("contains key five : "+map.containsKey("five"));

   // containsValue(Object value) :是否包含值value
   System.out.println("contains value 0 : "+map.containsValue(new Integer(0)));

   // remove(Object key) ： 删除键key对应的键值对
   map.remove("three");

   System.out.println("map:"+map );

   // clear() ： 清空HashMap
   map.clear();

   // isEmpty() : HashMap是否为空
   System.out.println((map.isEmpty()?"map is empty":"map is not empty") );
}
// 运行结果：
map:{one=1, two=0, three=0}
next : one - 1
next : two - 0
next : three - 0
size:3
contains key two : true
contains key five : false
contains value 0 : true
map:{one=1, two=0}
map is empty
```
:::
## LinkedHashMap
LinkedHashMap维护一个Entry的双向链表，保证了集合元素迭代的顺序，这个顺序可以是插入顺序或者访问顺序。<br>
LinkedHashMap继承自HashMap，它的多种操作都是建立在HashMap操作的基础上的。<br>
key和value都允许为null<br>
key重复会覆盖，value可以重复<br>
有序的<br>
LinkedHashMap是非线程安全的<br>
``` java
public class LinkedHashMap<K,V>
    extends HashMap<K,V>
    implements Map<K,V>
```
### LinkedHashMap 继承关系
``` java
public class HashMap<K,V> extends AbstractMap<K,V>
    implements Map<K,V>, Cloneable, Serializable
   |
public class LinkedHashMap<K,V>
    extends HashMap<K,V>
    implements Map<K,V>
```
### LinkedHashMap 源码解析
* 可以认为，LinkedHashMap=HashMap+LinkedList
   * 使用 HashMap 操作数据结构
   * 使用 LinkedList 维护插入元素的先后顺序
* LinkedHashMap的实现思想就是多态
<br>
<img src="/images/java/20200430000245372.png" width="60%" height="60%" />
<br><br>

为了实现双向链表，LinkedHashMap中提供了如下的Entry：<br>
``` java
/**
 * LinkedHashMap中的node直接继承自HashMap中的Node。并且增加了双向的指针
 */
static class Entry<K,V> extends HashMap.Node<K,V> {
   Entry<K,V> before, after;
   Entry(int hash, K key, V value, Node<K,V> next) {
      super(hash, key, value, next);
   }
}
```
主要变量：<br>
``` java
/**
 * 头指针，指向第一个node
 */
transient LinkedHashMap.Entry<K,V> head;

/**
 * 尾指针，指向最后一个node
 */
transient LinkedHashMap.Entry<K,V> tail;

/**
 * 一个条件变量，它控制了是否在get操作后需要将新的get的节点重新放到链表的尾部
 * LinkedHashMap可以维持了插入的顺序，但是这个顺序不是不变的，可以被get操作打乱。
 */
final boolean accessOrder;
```
### LinkedHashMap 排序
* 构造方法中，有个accessOrder，它不同的值有不同的意义:
   * false, 所有的Entry按照插入的顺序排列
   * true, 所有的Entry按照访问的顺序排列
      * 访问的顺序：如果有1 2 3这3个Entry，那么访问了1，就把1移到尾部去，即2 3 1。
      * 每次访问都把访问的那个数据移到双向队列的尾部去，那么每次要淘汰数据的时候，
      * 双向队列最头的那个数据不就是最不常访问的那个数据了吗？
      * 换句话说，双向链表最头的那个数据就是要淘汰的数据。
#### 插入顺序
默认是插入顺序，由默认的构造方法实现<br>
``` java
public LinkedHashMap() {
   super();
   accessOrder = false;
}
```
#### 访问顺序
调用以下构造方法实现<br>
``` java
public LinkedHashMap(int initialCapacity,
                     float loadFactor,
                     boolean accessOrder) {
   super(initialCapacity, loadFactor);
   this.accessOrder = accessOrder;
}
```
::: warning
利用LinkedHashMap实现LRU算法缓存<br>
所谓LRU：Least Recently Used，最近最少使用，即当缓存了，会优先淘汰那些最近不常访问的数据，即冷数据优先淘汰。
:::
### LinkedHashMap 方法说明
* get(Object key)
   * 根据指定的key值返回对应的value 	
* put(K key, V value)
   * 将指定的key, value对添加到map里。 	
* remove(Object key)
   * 删除key值对应的value 
### LinkedHashMap 实例
::: details 代码实例解析
``` java
public static void main(String[] args) {
   // 新建LinkedHashMap - 插入顺序
   HashMap mapInsert = new LinkedHashMap();
   // 添加操作
   mapInsert.put("one", 1);
   mapInsert.put("three", 3);
   mapInsert.put("two", 2);
   // 打印出map
   System.out.println("插入顺序：" + mapInsert);
   // 新建LinkedHashMap - 访问顺序
   HashMap mapGet = new LinkedHashMap(1 << 4, 0.75f, true);
   // 添加操作
   mapGet.put("one", 1);
   mapGet.put("three", 3);
   mapGet.put("two", 2);
   mapGet.get("three");
   mapGet.get("three");
   // 打印出map
   System.out.println("访问顺序：" + mapGet);
}
// 执行结果：
插入顺序：{one=1, three=3, two=2}
访问顺序：{one=1, two=2, three=3}
```
:::
## Hashtable
Hashtable 和 HashMap 有着相同的实现，前者仅仅是对后者做了一层包装，也就是说HashSet里面有一个HashMap<br>
Hashtable 的函数都是同步的，这意味着它是线程安全的。<br>
Hashtable 的key、value都不可以为null。<br>
Hashtable 中的映射不是有序的。<br>
``` java
public class Hashtable<K,V>
    extends Dictionary<K,V>
    implements Map<K,V>, Cloneable, java.io.Serializable
```
### Hashtable 继承关系
``` java
public abstract class Dictionary<K,V>
   |
public class Hashtable<K,V>
    extends Dictionary<K,V>
    implements Map<K,V>, Cloneable, java.io.Serializable
```
* Dictionary 类是一个抽象类，用来存储键/值对，作用和Map类相似。
* Map - 表示 Hashtable 是键值对结构，具备Map接口的所有功能。
* Cloneable - 表示 Hashtable 覆盖了函数clone()，能被克隆。
* Serializable - 表示 Hashtable 支持序列化，能通过序列化去传输。
### Hashtable 源码解析
详细内容参照 HashMap
### Hashtable 方法说明
详细内容参照 HashMap
### Hashtable 实例
::: details 代码实例解析
``` java
public static void main(String[] args) {
   // 初始化随机种子
   Random r = new Random();
   // 新建Hashtable
   Hashtable table = new Hashtable();
   // 添加操作
   table.put("one", r.nextInt(10));
   table.put("two", r.nextInt(10));
   table.put("three", r.nextInt(10));

   // 打印出table
   System.out.println("table:"+table );

   // 通过Iterator遍历key-value
   Iterator iter = table.entrySet().iterator();
   while(iter.hasNext()) {
      Map.Entry entry = (Map.Entry)iter.next();
      System.out.println("next : "+ entry.getKey() +" - "+entry.getValue());
   }

   // Hashtable的键值对个数
   System.out.println("size:"+table.size());

   // containsKey(Object key) :是否包含键key
   System.out.println("contains key two : "+table.containsKey("two"));
   System.out.println("contains key five : "+table.containsKey("five"));

   // containsValue(Object value) :是否包含值value
   System.out.println("contains value 0 : "+table.containsValue(new Integer(0)));

   // remove(Object key) ： 删除键key对应的键值对
   table.remove("three");

   System.out.println("table:"+table );

   // clear() ： 清空Hashtable
   table.clear();

   // isEmpty() : Hashtable是否为空
   System.out.println((table.isEmpty()?"table is empty":"table is not empty") );
}
// 运行结果：
table:{two=7, one=2, three=9}
next : two - 7
next : one - 2
next : three - 9
size:3
contains key two : true
contains key five : false
contains value 0 : false
table:{two=7, one=2}
table is empty
```
:::
## TreeMap
TreeMap 是一个有序的key-value集合，它是通过红黑树实现的。<br>
TreeMap 根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。<br>
TreeMap 是非同步的，即不是线程安全的。<br>
TreeMap 的 iterator 方法返回的迭代器是fail-fast的。<br>
``` java
public class TreeMap<K,V>
    extends AbstractMap<K,V>
    implements NavigableMap<K,V>, Cloneable, java.io.Serializable
```
### TreeMap 继承关系
``` java
public abstract class AbstractMap<K,V> implements Map<K,V>
  |
public class TreeMap<K,V>
    extends AbstractMap<K,V>
    implements NavigableMap<K,V>, Cloneable, java.io.Serializable
```
* 继承于AbstractMap - 表示 TreeMap 是一个Map，即一个key-value集合。
* NavigableMap - 表示 TreeMap 支持一系列的导航方法，比如返回有序的key集合。
* Cloneable - 表示 TreeMap 覆盖了函数clone()，能被克隆。
* Serializable - 表示 TreeMap 支持序列化，能通过序列化去传输。
### TreeMap 源码解析
TreeMap 基于红黑树（Red-Black tree）实现。<br>
TreeMap 存储的是key-value键值对。<br>
TreeMap 的排序是基于对key的排序。<br>
* TreeMap 包含几个重要的成员变量： root, size, comparator。											
   * root 是红黑数的根节点。										
      * 它是Entry类型，Entry是红黑数的节点，它包含了红黑数的6个基本组成成分：
         * key(键)、value(值)、left(左孩子)、right(右孩子)、parent(父节点)、color(颜色)。									
		* Entry节点根据key进行排序，Entry节点包含的内容为value。									
		* 红黑数排序时，根据Entry中的key进行排序；									
		* Entry中的key比较大小是根据比较器comparator来进行判断的									
   * size 是红黑数中节点的个数。
   * comparator 是比较器。

当查找树的结构发生改变时，红黑树的约束条件可能被破坏，需要通过调整使得查找树重新满足红黑树的约束条件。<br>
调整可以分为两类: 一类是颜色调整，即改变某个节点的颜色；另一类是结构调整，集改变检索树的结构关系。<br>
* 结构调整过程包含两个基本操作：
   * 左旋（Rotate Left）
      * 左旋的过程是将x的右子树绕x逆时针旋转，使得x的右子树成为x的父亲，同时修改相关节点的引用。
      * 旋转之后，二叉查找树的属性仍然满足。
   * 右旋（Rotate Right）
      * 右旋的过程是将x的左子树绕x顺时针旋转，使得x的左子树成为x的父亲，同时修改相关节点的引用。
      * 旋转之后，二叉查找树的属性仍然满足。

### TreeMap 方法说明
* get(Object key)
   * 根据指定的key值返回对应的value 	
* put(K key, V value)
   * 将指定的key, value对添加到map里。 	
* remove(Object key)
   * 删除key值对应的entry
   * 删除后，红黑树的约束会被破坏，需要调用fixAfterDeletion(Entry<K,V> x)进行调整。 	
* fixAfterDeletion(Entry<K,V> x)
   * 调整红黑树的结构
* rotateLeft(Entry<K,V> p) 
   * 左旋 	
* rotateRight(Entry<K,V> p)
   * 右旋 	
### TreeMap 遍历方式
::: details 代码实例解析
遍历TreeMap的键值对<br>
``` java
// 假设map是TreeMap对象						
// map中的key是String类型，value是Integer类型						
Integer integ = null;						
Iterator iter = map.entrySet().iterator();						
while(iter.hasNext()) {						
    Map.Entry entry = (Map.Entry)iter.next();						
    // 获取key						
    key = (String)entry.getKey();						
        // 获取value						
    integ = (Integer)entry.getValue();						
}						
```
遍历TreeMap的键值对<br>
``` java
// 假设map是TreeMap对象								
// map中的key是String类型，value是Integer类型								
String key = null;								
Integer integ = null;								
Iterator iter = map.keySet().iterator();								
while (iter.hasNext()) {								
        // 获取key								
    key = (String)iter.next();								
        // 根据key，获取value								
    integ = (Integer)map.get(key);								
}								
```
遍历TreeMap的值<br>
``` java
// 假设map是TreeMap对象
// map中的key是String类型，value是Integer类型
Integer value = null;
Collection c = map.values();
Iterator iter= c.iterator();
while (iter.hasNext()) {
    value = (Integer)iter.next();
}
```
:::
### TreeMap 实例
::: details 代码实例解析
``` java
package com.escco.test;

import java.util.*;

public class Test {

    public static void main(String[] args) {
        // 测试常用的API
        testTreeMapOridinaryAPIs();
        // 测试TreeMap的导航函数
        testNavigableMapAPIs();
        // 测试TreeMap的子Map函数
        testSubMapAPIs();
    }

    /**
     * 测试常用的API
     */
    private static void testTreeMapOridinaryAPIs() {
        // 初始化随机种子
        Random r = new Random();
        // 新建TreeMap
        TreeMap tmap = new TreeMap();
        // 添加操作
        tmap.put("one", r.nextInt(10));
        tmap.put("two", r.nextInt(10));
        tmap.put("three", r.nextInt(10));

        System.out.printf("\n ---- testTreeMapOridinaryAPIs ----\n");
        // 打印出TreeMap
        System.out.printf("%s\n",tmap );

        // 通过Iterator遍历key-value
        Iterator iter = tmap.entrySet().iterator();
        while(iter.hasNext()) {
            Map.Entry entry = (Map.Entry)iter.next();
            System.out.printf("next : %s - %s\n", entry.getKey(), entry.getValue());
        }

        // TreeMap的键值对个数
        System.out.printf("size: %s\n", tmap.size());

        // containsKey(Object key) :是否包含键key
        System.out.printf("contains key two : %s\n",tmap.containsKey("two"));
        System.out.printf("contains key five : %s\n",tmap.containsKey("five"));

        // containsValue(Object value) :是否包含值value
        System.out.printf("contains value 0 : %s\n",tmap.containsValue(new Integer(0)));

        // remove(Object key) ： 删除键key对应的键值对
        tmap.remove("three");

        System.out.printf("tmap:%s\n",tmap );

        // clear() ： 清空TreeMap
        tmap.clear();

        // isEmpty() : TreeMap是否为空
        System.out.printf("%s\n", (tmap.isEmpty()?"tmap is empty":"tmap is not empty") );
    }

    /**
     * 测试TreeMap的子Map函数
     */
    public static void testSubMapAPIs() {
        // 新建TreeMap
        TreeMap tmap = new TreeMap();
        // 添加“键值对”
        tmap.put("a", 101);
        tmap.put("b", 102);
        tmap.put("c", 103);
        tmap.put("d", 104);
        tmap.put("e", 105);

        System.out.printf("\n ---- testSubMapAPIs ----\n");
        // 打印出TreeMap
        System.out.printf("tmap:\n\t%s\n", tmap);

        // 测试 headMap(K toKey)
        System.out.printf("tmap.headMap(\"c\"):\n\t%s\n", tmap.headMap("c"));
        // 测试 headMap(K toKey, boolean inclusive)
        System.out.printf("tmap.headMap(\"c\", true):\n\t%s\n", tmap.headMap("c", true));
        System.out.printf("tmap.headMap(\"c\", false):\n\t%s\n", tmap.headMap("c", false));

        // 测试 tailMap(K fromKey)
        System.out.printf("tmap.tailMap(\"c\"):\n\t%s\n", tmap.tailMap("c"));
        // 测试 tailMap(K fromKey, boolean inclusive)
        System.out.printf("tmap.tailMap(\"c\", true):\n\t%s\n", tmap.tailMap("c", true));
        System.out.printf("tmap.tailMap(\"c\", false):\n\t%s\n", tmap.tailMap("c", false));

        // 测试 subMap(K fromKey, K toKey)
        System.out.printf("tmap.subMap(\"a\", \"c\"):\n\t%s\n", tmap.subMap("a", "c"));
        // 测试
        System.out.printf("tmap.subMap(\"a\", true, \"c\", true):\n\t%s\n",
                tmap.subMap("a", true, "c", true));
        System.out.printf("tmap.subMap(\"a\", true, \"c\", false):\n\t%s\n",
                tmap.subMap("a", true, "c", false));
        System.out.printf("tmap.subMap(\"a\", false, \"c\", true):\n\t%s\n",
                tmap.subMap("a", false, "c", true));
        System.out.printf("tmap.subMap(\"a\", false, \"c\", false):\n\t%s\n",
                tmap.subMap("a", false, "c", false));

        // 测试 navigableKeySet()
        System.out.printf("tmap.navigableKeySet():\n\t%s\n", tmap.navigableKeySet());
        // 测试 descendingKeySet()
        System.out.printf("tmap.descendingKeySet():\n\t%s\n", tmap.descendingKeySet());
    }

    /**
     * 测试TreeMap的导航函数
     */
    public static void testNavigableMapAPIs() {
        // 新建TreeMap
        NavigableMap nav = new TreeMap();
        // 添加“键值对”
        nav.put("aaa", 111);
        nav.put("bbb", 222);
        nav.put("eee", 333);
        nav.put("ccc", 555);
        nav.put("ddd", 444);

        System.out.printf("\n ---- testNavigableMapAPIs ----\n");

        // 打印出TreeMap
        System.out.printf("Whole list:%s%n", nav);

        // 获取第一个key、第一个Entry
        System.out.printf("First key: %s\tFirst entry: %s%n",nav.firstKey(), nav.firstEntry());

        // 获取最后一个key、最后一个Entry
        System.out.printf("Last key: %s\tLast entry: %s%n",nav.lastKey(), nav.lastEntry());

        // 获取“小于/等于bbb”的最大键值对
        System.out.printf("Key floor before bbb: %s%n",nav.floorKey("bbb"));

        // 获取“小于bbb”的最大键值对
        System.out.printf("Key lower before bbb: %s%n", nav.lowerKey("bbb"));

        // 获取“大于/等于bbb”的最小键值对
        System.out.printf("Key ceiling after ccc: %s%n",nav.ceilingKey("ccc"));

        // 获取“大于bbb”的最小键值对
        System.out.printf("Key higher after ccc: %s%n\n",nav.higherKey("ccc"));
    }

}
// 运行结果：
---- testTreeMapOridinaryAPIs ----
{one=0, three=1, two=4}
next : one - 0
next : three - 1
next : two - 4
size: 3
contains key two : true
contains key five : false
contains value 0 : true
tmap:{one=0, two=4}
tmap is empty

 ---- testNavigableMapAPIs ----
Whole list:{aaa=111, bbb=222, ccc=555, ddd=444, eee=333}
First key: aaa	First entry: aaa=111
Last key: eee	Last entry: eee=333
Key floor before bbb: bbb
Key lower before bbb: aaa
Key ceiling after ccc: ccc
Key higher after ccc: ddd


 ---- testSubMapAPIs ----
tmap:
	{a=101, b=102, c=103, d=104, e=105}
tmap.headMap("c"):
	{a=101, b=102}
tmap.headMap("c", true):
	{a=101, b=102, c=103}
tmap.headMap("c", false):
	{a=101, b=102}
tmap.tailMap("c"):
	{c=103, d=104, e=105}
tmap.tailMap("c", true):
	{c=103, d=104, e=105}
tmap.tailMap("c", false):
	{d=104, e=105}
tmap.subMap("a", "c"):
	{a=101, b=102}
tmap.subMap("a", true, "c", true):
	{a=101, b=102, c=103}
tmap.subMap("a", true, "c", false):
	{a=101, b=102}
tmap.subMap("a", false, "c", true):
	{b=102, c=103}
tmap.subMap("a", false, "c", false):
	{b=102}
tmap.navigableKeySet():
	[a, b, c, d, e]
tmap.descendingKeySet():
	[e, d, c, b, a]
```
:::
## WeakHashMap
``` java
```
### xxx 继承关系
``` java
```
### xxx 源码解析
### xxx 方法说明
### xxx 实例
## Properties
``` java
```
### xxx 继承关系
``` java
```
### xxx 源码解析
### xxx 方法说明
### xxx 实例
## IdentityHashMap
``` java
```
### xxx 继承关系
``` java
```
### xxx 源码解析
### xxx 方法说明
### xxx 实例
## EnumMap
``` java
```
### xxx 继承关系
``` java
```
### xxx 源码解析
### xxx 方法说明
### xxx 实例
# 正则表达式
::: tip
本文主要对正则表达式进行总结。@Frank Zhao
:::
## 本章目录
[[toc]]
## 概述
正则表达式就是用于描述规则的工具，换句话说，正则表达式就是记录文本规则的代码。<br>
正则表达式是文本字符串格式的，它会以定义的模式从左到右匹配文本，每个源字符只匹配一次。<br><br>
<img src="/images/java/1896874-20200701140224149-1020851468.png" width="50%" height="50%" /><br>

## 基本语法
| 符号 | 说明 |
|:-:|-|
| <b>XZ</b> | 匹配 X 后直接跟着 Z |
## 正则元字符
### 基本字符
| 符号 | 说明 |
|:-:|-|
| <b>.</b> | 匹配任意单个字符，除了换行符（Linux 中换行是 \n，Windows 中换行是 \r\n）<br>※ 如果需要匹配包括换行的任意字符，可以使用 [\\s\\S] 代替. |
| <b>^</b> | 匹配字符串开头 |
| <b>$</b> | 匹配字符串结尾 |
### 范围字符
| 符号 | 说明 |
|:-:|-|
| <b>[]</b> | 多选一，匹配内部任意单个字符，参照 [abc] 等的说明<br>[] 里面的特殊字符有五个：[ ] - \\ ^，其他字符都是普通字符，包括 * . ? \ \| 等都是普通字符。<br>关于 [] 常见的错误用法是：<br>&nbsp;&nbsp;&nbsp;&nbsp;[ab\|bc]用来表示ab或bc，实际上，它得到的结果是[abc\|]，即a或b或c或\|这4个字符（单字符）的任意一个。<br>&nbsp;&nbsp;&nbsp;&nbsp;正确的应该写成(ab\|bc)。 |
| <b>[abc]</b> | 复选集定义，匹配字母 a 或 b 或 c |
| <b>[abc][vz]</b> | 复选集定义，匹配字母 a 或 b 或 c，后面跟着 v 或 z |
| <b>[^abc]</b> | 当插入符 ^ 在中括号中以第一个字符开始显示，则表示否定模式。此模式匹配所有字符，除了 a 或 b 或 c |
| <b>[a-d1-7]</b> | 范围匹配，匹配字母 a 到 d 和数字从 1 到 7 之间 |
| <b>[a-z]</b> | 字符范围内匹配，匹配指定范围内的任意字符。<br>例如，[a-z]可以匹配a到z范围内的任意小写字母字符。 |
| <b>[^a-z]</b> | 字符范围外匹配，匹配指定范围外的任意字符。<br>例如，[^a-z]可以匹配a到z范围外的任意小写字母字符。 |
| <b>\|</b> | 或，用于匹配多个字符中的一个 |
| <b>X\|Z</b> | 匹配 X 或 Z |
| <b>()</b> | 子表达式，可以在正则表达式中再嵌套一个子正则表达式 |
### 特殊字符
| 符号 | 说明 |
|:-:|-|
| <b>\d</b> | 匹配一个数字，是 [0-9] 的简写 |
| <b>\D</b> | 匹配一个非数字，是 [^0-9] 的简写 |
| <b>\s</b> | 匹配所有的空白字符，包括空格、制表符、换页符、换行符、回车符 等等。等价于[ \t\f\n\r ]。<br>[\\s\\S]表示匹配任意字符 |
| <b>\S</b> | 匹配所有的非空白字符 |
| <b>\w</b> | 匹配一个单词字符（大小写字母、数字、下划线），是 [a-zA-Z_0-9] 的简写 |
| <b>\W</b> | 匹配一个非单词字符（除了大小写字母、数字、下划线之外的字符），等同于 [^\w] |
| <b>\b</b> | 匹配单词的开始或结束，也就是单词的边界处<br>例如：\ba\w*\b匹配以字母a开头的单词(\ba)，然后是任意数量的字母或数字(\w*)，最后是单词结束处(\b)<br>※ 不匹配任何字符，它只匹配一个位置（开头，结尾） |
| <b>\B</b> | 表示非单词边界 |
### 空白字符
| 符号 | 说明 |
|:-:|-|
| <b>\r</b> | 回车符 |
| <b>\n</b> | 换行符 |
| <b>\f</b> | 换页符 |
| <b>\t</b> | 制表符 |
| <b>\v</b> | 竖向制表符 |
* 不同系统在每行文本结束位置会有换行符，但不同系统的换行符会不一样
   * Windows \r\n
   * Linux   \n
   * macOS   \n
* 在正则中，也可以直接使用 \r 、 \n 来匹配对应的空白符
* 当然， \s 已经可以满足大部分空白符场景，它代表任意单个空白符，相当于 [\r\n\t\f] 空白符集合
### 限定符
| 符号 | 说明 |
|:-:|-|
| <b>*</b> | 匹配 >=0 个，是 {0,} 的简写<br>例如：X* 表示匹配零个或多个字母 X，.* 表示匹配任何字符串 |
| <b>+</b> | 匹配 >=1 个，是 {1,} 的简写<br>例如：X+ 表示匹配一个或多个字母 X |
| <b>?</b> | 匹配 1 个或 0 个，是 {0,1} 的简写<br>例如：X? 表示匹配 0 个或 1 个字母 X |
| <b>{X}</b> | 只匹配 X 个字符<br>例如：\d{3} 表示匹配 3 个数字，.{10} 表示匹配任何长度是 10 的字符串 |
| <b>{X,}</b> | 匹配 >=X<br>例如：\d{1,} 表示匹配至少 1 个数字 |
| <b>{X,Y}</b> | 匹配 >=X 且 <=Y 个<br>例如：\d{1,4} 表示匹配至少 1 个最多 4 个数字 |
### 转义字符
| 符号 | 说明 |
|:-:|-|
| <b>\\</b> | 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。<br>例如：'\n' 匹配换行符\n。序列 '\\\\' 匹配 "\\"，而 '\\(' 则匹配 "("。<br>例如：deerchao\\.cn匹配deerchao.cn，C:\\\\Windows匹配C:\Windows。 |
::: details 简单的正则表达式实例
实例一 <br>
``` java
String s = "abcde\\n";
Pattern pattern = Pattern.compile(".");
Matcher matcher = pattern.matcher(s);
while (matcher.find()) {
    System.out.print(matcher.group());
    System.out.print("、");
}
// 运行结果：a、b、c、d、e、\、n、
```
实例二 <br>
``` java
String s = "0198aAzZ\\w哎_-";
Pattern pattern = Pattern.compile("\\w");
Matcher matcher = pattern.matcher(s);
while (matcher.find()) {
    System.out.print(matcher.group());
    System.out.print("、");
}
// 运行结果：0、1、9、8、a、A、z、Z、w、_、
```
实例三 <br>
``` java
String s = "023-81200222、023-81200223、023-81200224";
Pattern pattern = Pattern.compile("0\\d{1,}-\\d{1,}");
Matcher matcher = pattern.matcher(s);
while (matcher.find()) {
    System.out.print(matcher.group());
    System.out.print("、");
}
// 运行结果：023-81200222、023-81200223、023-81200224、
```
:::
## 分组
在一个正则表达式中, 通过英文 () 包裹的子表达式内容, 就对应着一个分组<br>
正则表达式中的分组又称为子表达式，就是把一个正则表达式的全部或部分当做一个整体进行处理，分成一个或多个组。<br>
### 分组的编号规则
第几个括号就是第几个分组<br>
整个正则表达式所匹配到的文本, 就对应着分组0, 而我们显示指定的分组, 都是从1开始排序的<br>
例如下图这个表达式由两个子表达式组成，第一个分组是日期，第二个分组是时间<br>
<br>
<img src="/images/java/1896874.png" width="50%" height="50%" />

### 分组的嵌套
无论括号如何嵌套，分组的编号都是根据开括号出现顺序来计数的；<br>
开括号是从左向右数起第多少个开括号，整个括号分组的编号就是多少<br>
<br>
<img src="/images/java/b3177d1c440897afb425ecc923ade6e6.png" width="40%" height="30%" />
<br>

### 捕获分组
括号不仅能把元素进行分组，当正则表达式匹配完成之后，还会保留分组匹配的结果，<br>
所以在匹配完成之后，可以通过对应的分组编号来获取匹配的结果，<br>
所以这种功能叫做捕获分组，对应的， 这种括号叫做捕获型括号<br>
``` javascript
// javascript code
"http://www.baidu.com".match(/(\w+):\/\/(\w+\.\w+\.\w+)/);
// 会返回如下的结果
0: "http://www.baidu.com"
1: "http"
2: "www.baidu.com"
groups: undefined
// 索引0对应的就是整个匹配到的部分, 而索引1对应第一个分组, 也就是协义部分, 索引2对应着第二个分组, 也就是域名部分
```
### 非捕获分组
非捕获分组，只分组，不保留匹配结果，同时他也不会影响分组排序，因为排序的时候会忽略非捕获分组<br>
有些情况下，只想用括号将某些部分看成一个整体，临时使用，不分配编号，后续不再用<br>
通过 (?:表达式) 表示不保存分组<br>
``` javascript
// javascript code
"http://www.baidu.com".match(/(?:\w+):\/\/(\w+\.\w+\.\w+)/);
// 会返回如下的结果
0: "http://www.baidu.com"
1: "www.baidu.com"
groups: undefined
// 这次没有保留协义部分的匹配结果, 同时也没有影响匹配顺序
```
### 命名分组
捕获分组一般通过数组编号来引用匹配的内容，虽然是从左到右来计算编号，<br>
但是分组多了也难免混淆，因此可以采用对分组命名的方式来使分组更直观<br>
::: warning
在不同的语言语法中，命名分组的语法也不一样
:::
``` javascript
// javascript 语法
(?<name>)
// php 语法
(?<name>) 或者 (?P<name>) 或 (?'name')
```
``` javascript
// javascript code
"http://www.baidu.com".match(/(?<protocol>\w+):\/\/(?<domain>\w+\.\w+\.\w+)/);
// 返回结果
0: "http://www.baidu.com"
1: "http"
2: "www.baidu.com"
groups:
    domain: "www.baidu.com"
    protocol: "http"
```

### 分组引用
当一个正则表达式被分组后，每个组将会自动的分配一个组号用于代表该组的表达式，<br>
其中，组号的编制规则为：从左到右、以分组的左括号“(”为标志，<br>
第一个分组的组号为1，第二个分组的组号为2，以此类推。<br>
::: warning
在不同的语言语法中，分组引用的语法也不一样
:::
知道分组编号后，我们会需要引用分组，引用规则如下：<br>
``` javascript
// javascript 语法
查找时：$number 替换时：$number
// java 语法
查找时：\number 替换时：$number
```
``` javascript
// 使用数字来引用分组
\b(\w+)\b\s+\1\b
// 可以用来匹配重复的单词，像go go, 或者kitty kitty。
// 这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(\b(\w+)\b)，这个单词会被捕获到编号为1的分组中，
// 然后是1个或几个空白符(\s+)，最后是分组1中捕获的内容（也就是前面匹配的那个单词）(\1)。
----------------------------------------------
// 使用组名来引用分组
\b(?<Word>\w+)\b\s+\k<Word>\b
```
::: details 代码实例解析
Java中对分组的引用<br>
``` java
String s = "023-81200222、024-81200223、123-81200224";
Pattern pattern = Pattern.compile("(0\\d{1,})-(\\d{1,})");
Matcher matcher = pattern.matcher(s);
matcher.find();
System.out.println(matcher.group(0));
System.out.println(matcher.group(1));
System.out.println(matcher.group(2));
// 运行结果：
//   023-81200222
//   023
//   81200222
```
:::
## 环视（零宽断言）
环视，在不同的地方又称之为零宽断言，简称断言。 <br>
环视强调的是它所在的位置，前面或者后面，必须满足环视表达式中的匹配情况，才能匹配成功。 <br>
环视可以认为是虚拟加入到它所在位置的附加判断条件，并不消耗正则的匹配字符。<br>
### 环视语法
| 表达式 | 名称 | 含义 | 实例 |
|:-:|-|-|-|
| (?<=Y) | 肯定逆序环视 | 左边是Y | (?<=\d)th -> 代表左边是一个数字的th，例如9th |
| (?<!Y) | 否定逆序环视 | 左边不是Y | (?<=!\d)th -> 代表左边不是一个数字的th，例如health |
| (?=Y) | 肯定顺序环视 | 右边是Y | six(?=\d) -> 代表右边是一个数字的six，例如six6 |
| (?!Y) | 否定顺序环视 | 右边不是Y | hi(?!\d) -> 代表右边不是一个数字的hi，例如high |
::: danger
记忆口诀：< 看左边，没有 < 看右边，感叹号是非的意思
:::
### 环视的用法
::: details 代码实例解析
正则分块组合法-必须包含字母、数字、特殊字符<br>
``` javascript
正则：
    ^(?=.*?[a-z])(?=.*?\d)(?![a-z\d]+$).+$ 
解析： 
    (?=.*?[a-z])限制必须有字母 
    (?=.*?\d)限制必须有数字 
    (?![a-z\d]+$)限制从开头到结尾不能全为数字和字母 
    .+在没有限定的情况下可以是任意字符 
    ^和$ 限定字符串的开头和结尾 
    组合起来就可以得到上面正则。
```
正则逐步完善法-排除特定标签p/a/img，匹配html标签<br>
``` javascript
正则：</?(?!p|a|img)([^> /]+)[^>]*/?>  
```
:::
## 贪婪模式、非贪婪模式与独占模式
* 贪婪模式，表示数量的限定符，默认都是贪婪的，简单说就是尽可能进行最长匹配，需要回溯才能完成相应的功能
* 非贪婪模式，表示数量的限定符后加上?，表示非贪婪的，则会尽可能进行最短匹配，需要回溯才能完成相应的功能
* 独占模式：表示数量的限定符后加上+，它类似贪婪匹配，但匹配过程不会发生回溯，因此在一些场合下性能会更好
   * 如果匹配失败就结束，不会进行回溯，这样的话就比较节省时间 
::: danger
不是所有语言都支持独占模式，Python 和 Go 的标准库目前都不支持独占模式
:::

| 模式 | 语法 |  正则 | 文本 | 结果 |
|:-:|:-:|-|-|-|
| 贪婪模式 |  | a{1,3}ab | aaab | 匹配 |
| 非贪婪模式 | ? | a{1,3}?ab | aaab | 匹配 |
| 独占模式 | + | a{1,3}+ab | aaab | 不匹配 |
※ 分析：a{1,3}+已尽力去配了aaa，因为不回溯，所以没有匹配上后面的ab<br>
## 注释
``` java
// 语法
(?#comment)
// 例如
2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)
```
要包含注释的话，最好是启用“忽略模式里的空白符”选项，<br>
这样在编写表达式时能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略。<br>
启用这个选项后，在#后面到这一行结束的所有文本都将被当成注释忽略掉。<br>
例如，我们可以前面的一个表达式写成这样：<br>
``` java
(?<=    # 断言要匹配的文本的前缀
<(\w+)> # 查找尖括号括起来的内容
        # (即HTML/XML标签)
)       # 前缀结束
.*      # 匹配任意文本
(?=     # 断言要匹配的文本的后缀
<\/\1>  # 查找尖括号括起来的内容
        # 查找尖括号括起来的内容
)       # 后缀结束
```
## 处理选项
| 名称 | 意义 | 说明 |
|:-:|-|-|
| IgnoreCase | 忽略大小写 | 匹配时不区分大小写。 |
| Multiline | 多行模式 | 更改^和$的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。<br>在此模式下, $ 的精确含意是:匹配 \n 之前的位置以及字符串结束前的位置 |
| Singleline | 单行模式 | 更改 . 的含义，使它与每一个字符匹配（包括换行符\n）。 |
| IgnorePatternWhitespace | 忽略空白 | 忽略表达式中的非转义空白并启用由#标记的注释。 |
| ExplicitCapture | 显式捕获 | 仅捕获已被显式命名的组。 |
::: warning
不同的开发语言，对应的处理选项可能不同，请注意
:::
``` javascript
// javascript
Regex regex = new Regex(@"\ba\w{6}\b", RegexOptions.IgnoreCase);
// java
Pattern pat = Pattern.compile(regEx, Pattern.CASE_INSENSITIVE);
```
## 平衡组
平衡组，故名思义，平衡即对称，主要是结合几种正则语法规则，提供对配对出现的嵌套结构的匹配。<br>
如果想要匹配可嵌套的层次性结构的话，就得使用平衡组了。<br>
::: warning
平衡组并不是所有程序语言都支持，PHP语言就不支持
:::
| 语法 | 说明 |
|:-:|-|
| (?\<group\>) | 把捕获的内容命名为group，并压入堆栈 |
| (?\<\-group\>) | 从堆栈上弹出最后压入堆栈的名为group的捕获内容，如果堆栈本来为空，则本分组的匹配失败 |
| (?(group)yes\|no) | 如果堆栈上存在以名为group的捕获内容的话，继续匹配yes部分的表达式，否则继续匹配no部分 |
| (?!) | 顺序否定环视，由于没有后缀表达式，试图匹配总是失败 |
``` java
需求说明：匹配成对出现的()中的内容
源字符串：a+(b*(c+d))/e+f-(g/(h-i))*j
正则表达式：((?<Open>\()|(?<−Open>)|[^()])*(?(Open)(?!))\)
输出结果：(b*(c+d)) 和 (g/(h-i))
说明：
 \(               #普通字符“(”
   (              #分组构造，用来限定量词“*”修饰范围
     (?<Open>\()  #命名捕获组，遇到开括弧“Open”计数加1
     |            #分支结构
     (?<-Open>\)) #狭义平衡组，遇到闭括弧“Open”计数减1
     |            #分支结构
     [^()]+       #非括弧的其它任意字符
   )*             #以上子串出现0次或任意多次
   (?(Open)(?!))  #判断是否还有“Open”，有则说明不配对，什么都不匹配
 \)               #普通闭括弧
```
## 模式修饰符
| 语法 | 说明 |
|:-:|-|
| /g | 表示该表达式将用来在输入字符串中查找所有可能的匹配，返回的结果可以是多个。<br>如果不加/g最多只会匹配一个 |
| /i | 表示匹配的时候不区分大小写，这个跟其它语言的正则用法相同 |
| /m | 表示多行匹配。什么是多行匹配呢？就是匹配换行符两端的潜在匹配。影响正则中的^$符号 |
| /s | 与/m相对，单行模式匹配。 |
| /e | 可执行模式，此为PHP专有参数，例如preg_replace函数。 |
| /x | 忽略空白模式。 |
::: warning
模式修饰符可以同时使用
:::
``` java
/[a-z0-9]/i，表示匹配字母数字，不区分大小写。
```
## 高级说明
### 按单字符匹配
正则里面的数据都是按照单个字符来进行匹配的<br>
比如，我要匹配0-15的数值区间，用正则来写的话，便是[0-9]|1[0-5]，<br>
这里，便是把0-9这种单字符的情况，和10-15这种多字符的情况拆分开了，使用分支|来区分开，表示要么是0-9，要么是10-15。<br>
``` java
现在延伸至1-65535，我个人的处理思想是从大到小，一块块分解：
1. 65530-65535  ==>  6553[0-5]          末位区间0-5
2. 65500-65529  ==>  655[0-2][0-9]      第四位区间0-2，末位区间0-9
3. 65000-65499  ==>  65[0-4][0-9]{2}    第三位区间0-4，后两位0-9
4. 60000-64999  ==>  6[0-4][0-9]{3}     第二位区间0-4，后三位0-9
5. 10000-59999  ==>  [1-5][0-9]{4}      第一位区间1-5，后四位0-9
6. 1-9999       ==>  [1-9][0-9]{0,3}    第一位只能是1-9，后三位可有可无
最后组合起来：
(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3})
便得到1-65535匹配正则
```
### 中文的匹配
[\u4e00-\u9fa5]+ 代表匹配中文字。
::: details 代码实例解析
``` java
public static void main(String[] args) {
   String str = "閑人b到a人间";
   Pattern pattern = Pattern.compile("[\\u4e00-\\u9fa5]+");
   Matcher matcher = pattern.matcher(str);
   while (matcher.find()) {
      System.out.print(matcher.group());
   }
   // 输出结果：閑人到人间
}
```
:::
### 数字范围的匹配
比如，匹配 1990 到 2017。<br>
注意：这里有个新手易范的错误，就是正则 [1990-2017]，实际这个正则只匹配 0 或 1 或 2 或 7 或 9 中的任一个字符。<br>
正则表达式匹配数字范围时，首先要确定最大值与最小值，最后写中间值。<br>
::: details 代码实例解析
``` java
public static void main(String[] args) {
   String str = "1990\n2010\n2017";
   // 这里应用了 (?m) 的多行匹配模式，只为方便我们测试输出
   // "^1990$|^199[1-9]$|^20[0-1][0-6]$|^2017$" 为判断 1990-2017 正确的正则表达式
   Pattern pattern = Pattern.compile("(?m)^1990$|^199[1-9]$|^20[0-1][0-6]$|^2017$");
   Matcher matcher = pattern.matcher(str);
   while (matcher.find()) {
      System.out.println(matcher.group());
   }
   // 输出结果：
   // 1990
   // 2010
   // 2017
}
```
:::
### img标签的匹配
比如，获取图片文件内容，这里我们考虑了一些不规范的 img 标签写法：
::: details 代码实例解析
``` java
public static void main(String[] args) {
   String str = "<img  src='aaa.jpg' /><img src=bbb.png/><img src=\"ccc.png\"/>" +
            "<img src='ddd.exe'/><img src='eee.jpn'/>";
   // 这里我们考虑了一些不规范的 img 标签写法，比如：空格、引号
   Pattern pattern = Pattern.compile("<img\\s+src=(?:['\"])?(?<src>\\w+.(jpg|png))(?:['\"])?\\s*/>");
   Matcher matcher = pattern.matcher(str);
   while (matcher.find()) {
      System.out.println(matcher.group("src"));
   }
   // 输出结果：
   // aaa.jpg
   // bbb.png
   // ccc.png
}
```
:::
### 正则表达式工具
#### 综合工具 - RegexBuddy
官方网址：https://www.regexbuddy.com/manual.html
使用说明：http://www.zjmainstay.cn/regex-tool-regexbuddy
#### 可视化理解正则 - Regulex
在线网址：https://jex.im/regulex/#!flags=&re=%5E(a%7Cb)*%3F%24
#### 在线测试正则 - 菜鸟工具
在线网址：http://c.runoob.com/front-end/854
### 正则三段论应用
正则三段论：定锚点，去噪点，取数据<br>
``` java
需求 -> 匹配作者名字
源数据 -> 标题：深入正则表达式应用，作者：Zjmainstay
(1) 定锚点：作者：
(2) 去噪点：标题：等就是没用的数据，不需要考虑到正则中
(3) 取数据：确定正则表达式为 -> 作者：(.*)
```
``` java
需求 -> 提取链接和标题，还有a标签的文字
源数据 -> <a href="http://www.zjmainstay.cn/my-regexp" class="demo8" title="正则三段论应用举例">正则表达式入门教程</a>
(1) 定锚点：
我们必须定位好锚点，主要有：
   1. <a //必须是a标签
   2. href=" 和 " //href=""的内容得到链接
   3. title=" 和 " //title=""的内容得到标题
   4. > 和 </a> //>和</a>的内容得到标签文字
(2) 去噪点：
   除了锚点，其他的都是噪点，使用.*?替代
(3) 取数据：
   提取的数据部分使用括号获取子模式，得到分组数据，因此得到正则：<a href="(.*?)".*?title="(.*?)">(.*?)</a>
```
## Java 正则表达式
### String 类
* public String[] split(String regex)
   * 根据给定的正则表达式的匹配来拆分此字符串。
   * 例如：将字符串 "boo:and:foo" , 用 : 来分拆，得到如下结果：{ "boo", "and", "foo" }
* public String[] split(String regex, int limit)
   * 根据匹配给定的正则表达式来拆分limit次此字符串。
   * 例如：将字符串 "boo:and:foo" , 用 : 来分拆 2 次，{ "boo", "and:foo" }
      * 如果该限制 n 大于 0，则模式将被最多应用 n - 1 次，数组的长度将不会大于 n，而且数组的最后项将包含超出最后匹配的定界符的所有输入。
      * 如果 n 为非正，则模式将被应用尽可能多的次数，而且数组可以是任意长度。
      * 如果 n 为零，则模式将被应用尽可能多的次数，数组可有任何长度，并且结尾空字符串将被丢弃。
* public String replaceAll(String regex, String replacement)
   * 使用给定的 replacement 字符串替换此字符串匹配给定的正则表达式的每个子字符串。
* public String replaceFirst(String regex, String replacement)
   * 使用给定的 replacement 字符串替换此字符串匹配给定的正则表达式的第一个子字符串。
::: details 代码实例解析
``` java
public static void main(String[] args) {
   // 去除单词与 , 和 . 之间的空格
   String Str = "Hello , World .";
   String pattern = "(\\w)(\\s+)([.,])";
   // $0 匹配 `(\w)(\s+)([.,])` 结果为 `o空格,` 和 `d空格.`
   // $1 匹配 `(\w)` 结果为 `o` 和 `d`
   // $2 匹配 `(\s+)` 结果为 `空格` 和 `空格`
   // $3 匹配 `([.,])` 结果为 `,` 和 `.`
   System.out.println(Str.replaceAll(pattern, "$1$3")); // Hello, World.
   // 输出结果：Hello, World.
}
```
上面的例子中，我们使用了 [.] 来匹配普通字符 . 而不需要使用 [\\.]。<br>
因为正则对于 [] 中的 .，会自动处理为 [\.]，即普通字符 . 进行匹配。
<br>
:::
### MatchResult 类
匹配操作的结果。<br>
此接口包含用于确定与正则表达式匹配结果的查询方法。<br>
通过 MatchResult 可以查看匹配边界、组和组边界，但是不能修改<br>
### Matcher 类
通过解释 Pattern 对 字符序列 执行匹配操作的引擎。<br>
* matcher 方法
   * 从模式创建匹配器。创建匹配器后，可以使用它执行三种不同的匹配操作：
* matches 方法
   * 尝试将整个输入序列与该模式匹配。
* lookingAt 方法
   * 尝试将输入序列从头开始与该模式匹配。
* find 方法
   * 扫描输入序列以查找与该模式匹配的下一个子序列。
* start()和end()
   * 如果匹配成功，start()会返回此次匹配的开始位置，end()会返回此次匹配的结束位置，即最后一个字符的下标加一。	
   * 如果之前的匹配不成功(或者没匹配)，那么无论是调用start()还是end()，都会引发一个IllegalStateException。		
* Groups	
   * Group是指里用括号括起来的，能被后面的表达式调用的正则表达式。	
   * Group 0 表示整个表达式，group 1 表示第一个被括起来的group，以此类推。	

### Pattern 类
正则表达式的编译表示形式。<br>
指定为字符串的正则表达式必须首先被编译为此类的实例。<br>
然后，可将得到的模式用于创建 Matcher 对象，依照正则表达式，该对象可以与任意字符序列匹配。<br>
执行匹配所涉及的所有状态都驻留在匹配器中，所以多个匹配器可以共享同一模式。<br><br>
可用的匹配模式如下：<br>
| Java常量 | 表达式 | 说明 |
|:-:|-|-|
| Pattern.CANON_EQ |  |  |
| Pattern.CASE_INSENSITIVE | (?i) | 忽略匹配字符的大小写。默认情况下，该标志仅仅考虑美国的ASCII码字符 |
| Pattern.COMMENTS | (?x) | 匹配时会忽略（正则表达式里的）空格字符<br>注：不是指表达式里的"//s"，而是指表达式里的空格，tab，回车之类。<br>注释从#开始，一直到这行结束。可以通过嵌入式的标志来启用Unix行模式。 |
| Pattern.DOTALL | (?s) | 表达式'.'可以匹配任意字符，包括表示一行的结束符。默认情况下，表达式'.'不匹配行的结束符。 |
| Pattern.MULTILINE | (?m) | ^和$分别匹配一行的开始和结束。此外，'^'仍然匹配字符串的开始，'$'也匹配字符串的结束。<br>默认情况下，这两个表达式仅仅匹配字符串的开始和结束。 |
| Pattern.UNICODE_CASE | (?u) | 当与CASE_INSENSITIVE标志一起使用时，它会使用Unicode码字符进行大小写不明感的匹配。 |
| Pattern.UNIX_LINES | (?d) | 只有'/n'才被认作一行的中止，并且与'.'，'^'，以及'$'进行匹配。 |
### 指定正则表达式的模式
* 可以在正则的开头指定模式修饰符。
   * (?i) 使正则忽略大小写
   * (?s) 表示单行模式（"single line mode"），使正则的 . 匹配所有字符，包括换行符。
   * (?m) 表示多行模式（"multi-line mode"），使正则的 ^ 和 $ 匹配字符串中每行的开始和结束。
::: details 代码实例解析
实例一<br>
``` java
public static void main(String[] args) {
    // 要验证的字符串
    String str = "baike.xsoftlab.net";
    // 正则表达式规则
    String regEx = "baike.*";
    // 编译正则表达式
    Pattern pattern = Pattern.compile(regEx);
    // 忽略大小写的写法
    // Pattern pat = Pattern.compile(regEx, Pattern.CASE_INSENSITIVE);
    Matcher matcher = pattern.matcher(str);
    // 查找字符串中是否有匹配正则表达式的字符/字符串
    boolean rs = matcher.find();
    System.out.println(rs);
    // 输出结果：true
}
```
实例二<br>
``` java
public static void main(String[] args) {
   String str = "img.jpg";
   // 分组且创建反向引用
   Pattern pattern = Pattern.compile("(jpg|png)");
   Matcher matcher = pattern.matcher(str);
   while (matcher.find()) {
      System.out.println(matcher.group());
      System.out.println(matcher.group(1));
   }
   // 输出结果：
   // jpg
   // jpg
}
```
实例三<br>
``` java
public static void main(String[] args) {
   String str = "@wxj 你好啊";
   Pattern pattern = Pattern.compile("@(?<first>\\w+\\s)"); // 保存一个副本
   Matcher matcher = pattern.matcher(str);
   while (matcher.find()) {
      System.out.println(matcher.group());
      System.out.println(matcher.group(1));
      System.out.println(matcher.group("first"));
   }
   // 输出结果：
   // @wxj 
   // wxj 
   // wxj 
}
```
实例思<br>
``` java
public static void main(String[] args) {
   String text = "Hello Regex!";
   Pattern pattern = Pattern.compile("\\w+");
   // Java 中忽略大小写，有两种写法：
   // Pattern pattern = Pattern.compile("\\w+", Pattern.CASE_INSENSITIVE);
   // Pattern pattern = Pattern.compile("(?i)\\w+"); // 推荐写法
   Matcher matcher = pattern.matcher(text);
   // 遍例所有匹配的序列
   while (matcher.find()) {
      System.out.print("Start index: " + matcher.start());
      System.out.print(" End index: " + matcher.end() + " ");
      System.out.println(matcher.group());
   }
   // 创建第两个模式，将空格替换为 tab
   Pattern replace = Pattern.compile("\\s+");
   Matcher matcher2 = replace.matcher(text);
   System.out.println(matcher2.replaceAll("\t"));
   // 输出结果：
   // Start index: 0 End index: 5 Hello
   // Start index: 6 End index: 11 Regex
   // Hello	Regex!
}
```
实例五<br>
``` java
public static void main(String[] args) {
   String str = "<div>文章标题</div><div>发布时间</div>";
   // 贪婪模式
   Pattern pattern = Pattern.compile("<div>(?<title>.+)</div>");
   Matcher matcher = pattern.matcher(str);
   while (matcher.find()) {
      System.out.println(matcher.group("title"));
   }
   System.out.println("--------------");
   // 非贪婪模式
   pattern = Pattern.compile("<div>(?<title>.+?)</div>");
   matcher = pattern.matcher(str);
   while (matcher.find()) {
      System.out.println(matcher.group("title"));
   }
   // 输出结果：
   // 文章标题</div><div>发布时间
   // --------------
   // 文章标题
   // 发布时间
}
```
:::
## 常用正则表达式
### 校验数字的表达式
* 数字：^[0-9]*$ 
* n位的数字：^\d{n}$ 
* 至少n位的数字：^\d{n,}$ 
* m-n位的数字：^\d{m,n}$ 
* 零和非零开头的数字：^(0|[1-9][0-9]*)$ 
* 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(\.[0-9]{1,2})?$ 
* 带1-2位小数的正数或负数：^(\-)?\d+(\.\d{1,2})$ 
* 正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$ 
* 有两位小数的正实数：^[0-9]+(\.[0-9]{2})?$ 
* 有1~3位小数的正实数：^[0-9]+(\.[0-9]{1,3})?$ 
* 非零的正整数：^[1-9]\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\+?[1-9][0-9]*$ 
* 非零的负整数：^\-[1-9][]0-9"*$ 或 ^-[1-9]\d*$ 
* 非负整数：^\d+$ 或 ^[1-9]\d*|0$ 
* 非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$ 
* 非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$ 
* 非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$ 
* 正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.+ [0-9]+)|([0-9]*[1-9][0-9]*))$ 
* 负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$ 
* 浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$ 
### 校验字符的表达式
* 汉字：^[\u4e00-\u9fa5]{0,}$ 
* 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 
* 长度为3-20的所有字符：^.{3,20}$ 
* 由26个英文字母组成的字符串：^[A-Za-z]+$ 
* 由26个大写英文字母组成的字符串：^[A-Z]+$ 
* 由26个小写英文字母组成的字符串：^[a-z]+$ 
* 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 
* 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$ 
* 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$ 
* 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$ 
* 可以输入含有^%&',;=?$"等字符：[^%&',;=?$\x22]+ 
* 禁止输入含有~的字符：[^~\x22]+ 
### 特殊需求表达式
* Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$ 
* 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(\.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+\.? 
* InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&=]*)?$ 
* 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|4|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$ 
* 电话号码("XXX-XXXXXXX"、"XXXX-XXXXXXXX"、"XXX-XXXXXXX"、"XXX-XXXXXXXX"、"XXXXXXX"和"XXXXXXXX)：^(\(\d{3,4}-)|\d{3.4}-)?\d{7,8}$ 
* 国内电话号码(0511-4405222、021-87888822)：\d{3}-\d{8}|\d{4}-\d{7} 
* 电话号码正则表达式（支持手机号码，3-4位区号，7-8位直播号码，1－4位分机号）: ((\d{11})|^((\d{7,8})|(\d{4}|\d{3})-(\d{7,8})|(\d{4}|\d{3})-(\d{7,8})-(\d{4}|\d{3}|\d{2}|\d{1})|(\d{7,8})-(\d{4}|\d{3}|\d{2}|\d{1}))$) 
* 身份证号(15位、18位数字)，最后一位是校验位，可能为数字或字符X：(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$) 
* 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 
* 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$ 
* 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在 8-10 之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])[a-zA-Z0-9]{8,10}$ 
* 强密码(必须包含大小写字母和数字的组合，可以使用特殊字符，长度在8-10之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ 
* 日期格式：^\d{4}-\d{1,2}-\d{1,2} 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 
* 钱的输入格式：
   * 有四种钱的表示形式我们可以接受:"10000.00" 和 "10,000.00", 和没有 "分" 的 "10000" 和 "10,000"：^[1-9][0-9]*$ 
   * 这表示任意一个不以0开头的数字,但是,这也意味着一个字符"0"不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 
   * 一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 
   * 这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧。下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 
   * 必须说明的是,小数点后面至少应该有1位数,所以"10."是不通过的,但是 "10" 和 "10.2" 是通过的：^[0-9]+(.[0-9]{2})?$ 
   * 这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 
   * 这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 
   * 1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 
   * 备注：这就是最终结果了,别忘了"+"可以用"*"替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里 
* xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$ 
* 中文字符的正则表达式：[\u4e00-\u9fa5] 
* 双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 
* 空白行的正则表达式：\n\s*\r (可以用来删除空白行) 
* HTML标记的正则表达式：<(\S*?)[^>]*>.*?|<.*? /> ( 首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 
* 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始) 
* 中国邮政编码：[1-9]\d{5}(?!\d) (中国邮政编码为6位数字) 
* IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))
# 正则表达式
::: tip
本文主要对正则表达式进行总结。@Frank Zhao
:::
## 本章目录
[[toc]]
## 概述
正则表达式就是用于描述规则的工具，换句话说，正则表达式就是记录文本规则的代码。<br>
正则表达式是文本字符串格式的，它会以定义的模式从左到右匹配文本，每个源字符只匹配一次。<br><br>
<img src="/images/java/1896874-20200701140224149-1020851468.png" width="50%" height="50%" /><br>

## 基本语法
| 符号 | 说明 |
|:-:|-|
| <b>XZ</b> | 匹配 X 后直接跟着 Z |
## 正则元字符
### 基本字符
| 符号 | 说明 |
|:-:|-|
| <b>.</b> | 匹配任意单个字符，除了换行符（Linux 中换行是 \n，Windows 中换行是 \r\n）<br>※ 如果需要匹配包括换行的任意字符，可以使用 [\\s\\S] 代替. |
| <b>^</b> | 匹配字符串开头 |
| <b>$</b> | 匹配字符串结尾 |
### 范围字符
| 符号 | 说明 |
|:-:|-|
| <b>[]</b> | 多选一，匹配内部任意单个字符，参照 [abc] 等的说明<br>[] 里面的特殊字符有五个：[ ] - \\ ^，其他字符都是普通字符，包括 * . ? \ \| 等都是普通字符。<br>关于 [] 常见的错误用法是：<br>&nbsp;&nbsp;&nbsp;&nbsp;[ab\|bc]用来表示ab或bc，实际上，它得到的结果是[abc\|]，即a或b或c或\|这4个字符（单字符）的任意一个。<br>&nbsp;&nbsp;&nbsp;&nbsp;正确的应该写成(ab\|bc)。 |
| <b>[abc]</b> | 复选集定义，匹配字母 a 或 b 或 c |
| <b>[abc][vz]</b> | 复选集定义，匹配字母 a 或 b 或 c，后面跟着 v 或 z |
| <b>[^abc]</b> | 当插入符 ^ 在中括号中以第一个字符开始显示，则表示否定模式。此模式匹配所有字符，除了 a 或 b 或 c |
| <b>[a-d1-7]</b> | 范围匹配，匹配字母 a 到 d 和数字从 1 到 7 之间 |
| <b>[a-z]</b> | 字符范围内匹配，匹配指定范围内的任意字符。<br>例如，[a-z]可以匹配a到z范围内的任意小写字母字符。 |
| <b>[^a-z]</b> | 字符范围外匹配，匹配指定范围外的任意字符。<br>例如，[^a-z]可以匹配a到z范围外的任意小写字母字符。 |
| <b>\|</b> | 或，用于匹配多个字符中的一个 |
| <b>X\|Z</b> | 匹配 X 或 Z |
| <b>()</b> | 子表达式，可以在正则表达式中再嵌套一个子正则表达式 |
### 特殊字符
| 符号 | 说明 |
|:-:|-|
| <b>\d</b> | 匹配一个数字，是 [0-9] 的简写 |
| <b>\D</b> | 匹配一个非数字，是 [^0-9] 的简写 |
| <b>\s</b> | 匹配所有的空白字符，包括空格、制表符、换页符、换行符、回车符 等等。等价于[ \t\f\n\r ]。<br>[\\s\\S]表示匹配任意字符 |
| <b>\S</b> | 匹配所有的非空白字符 |
| <b>\w</b> | 匹配一个单词字符（大小写字母、数字、下划线），是 [a-zA-Z_0-9] 的简写 |
| <b>\W</b> | 匹配一个非单词字符（除了大小写字母、数字、下划线之外的字符），等同于 [^\w] |
| <b>\b</b> | 匹配单词的开始或结束，也就是单词的边界处<br>例如：\ba\w*\b匹配以字母a开头的单词(\ba)，然后是任意数量的字母或数字(\w*)，最后是单词结束处(\b)<br>※ 不匹配任何字符，它只匹配一个位置（开头，结尾） |
| <b>\B</b> | 表示非单词边界 |
### 空白字符
| 符号 | 说明 |
|:-:|-|
| <b>\r</b> | 回车符 |
| <b>\n</b> | 换行符 |
| <b>\f</b> | 换页符 |
| <b>\t</b> | 制表符 |
| <b>\v</b> | 竖向制表符 |
* 不同系统在每行文本结束位置会有换行符，但不同系统的换行符会不一样
   * Windows \r\n
   * Linux   \n
   * macOS   \n
* 在正则中，也可以直接使用 \r 、 \n 来匹配对应的空白符
* 当然， \s 已经可以满足大部分空白符场景，它代表任意单个空白符，相当于 [\r\n\t\f] 空白符集合
### 限定符
| 符号 | 说明 |
|:-:|-|
| <b>*</b> | 匹配 >=0 个，是 {0,} 的简写<br>例如：X* 表示匹配零个或多个字母 X，.* 表示匹配任何字符串 |
| <b>+</b> | 匹配 >=1 个，是 {1,} 的简写<br>例如：X+ 表示匹配一个或多个字母 X |
| <b>?</b> | 匹配 1 个或 0 个，是 {0,1} 的简写<br>例如：X? 表示匹配 0 个或 1 个字母 X |
| <b>{X}</b> | 只匹配 X 个字符<br>例如：\d{3} 表示匹配 3 个数字，.{10} 表示匹配任何长度是 10 的字符串 |
| <b>{X,}</b> | 匹配 >=X<br>例如：\d{1,} 表示匹配至少 1 个数字 |
| <b>{X,Y}</b> | 匹配 >=X 且 <=Y 个<br>例如：\d{1,4} 表示匹配至少 1 个最多 4 个数字 |
### 转义字符
| 符号 | 说明 |
|:-:|-|
| <b>\\</b> | 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。<br>例如：'\n' 匹配换行符\n。序列 '\\\\' 匹配 "\\"，而 '\\(' 则匹配 "("。<br>例如：deerchao\\.cn匹配deerchao.cn，C:\\\\Windows匹配C:\Windows。 |
::: details 简单的正则表达式实例
实例一 <br>
``` java
String s = "abcde\\n";
Pattern pattern = Pattern.compile(".");
Matcher matcher = pattern.matcher(s);
while (matcher.find()) {
    System.out.print(matcher.group());
    System.out.print("、");
}
// 运行结果：a、b、c、d、e、\、n、
```
实例二 <br>
``` java
String s = "0198aAzZ\\w哎_-";
Pattern pattern = Pattern.compile("\\w");
Matcher matcher = pattern.matcher(s);
while (matcher.find()) {
    System.out.print(matcher.group());
    System.out.print("、");
}
// 运行结果：0、1、9、8、a、A、z、Z、w、_、
```
实例三 <br>
``` java
String s = "023-81200222、023-81200223、023-81200224";
Pattern pattern = Pattern.compile("0\\d{1,}-\\d{1,}");
Matcher matcher = pattern.matcher(s);
while (matcher.find()) {
    System.out.print(matcher.group());
    System.out.print("、");
}
// 运行结果：023-81200222、023-81200223、023-81200224、
```
:::
## 分组
在一个正则表达式中, 通过英文 () 包裹的子表达式内容, 就对应着一个分组<br>
正则表达式中的分组又称为子表达式，就是把一个正则表达式的全部或部分当做一个整体进行处理，分成一个或多个组。<br>
### 分组的编号规则
第几个括号就是第几个分组<br>
整个正则表达式所匹配到的文本, 就对应着分组0, 而我们显示指定的分组, 都是从1开始排序的<br>
例如下图这个表达式由两个子表达式组成，第一个分组是日期，第二个分组是时间<br>
<br>
<img src="/images/java/1896874.png" width="50%" height="50%" />

### 分组的嵌套
无论括号如何嵌套，分组的编号都是根据开括号出现顺序来计数的；<br>
开括号是从左向右数起第多少个开括号，整个括号分组的编号就是多少<br>
<br>
<img src="/images/java/b3177d1c440897afb425ecc923ade6e6.png" width="40%" height="30%" />
<br>

### 捕获分组
括号不仅能把元素进行分组，当正则表达式匹配完成之后，还会保留分组匹配的结果，<br>
所以在匹配完成之后，可以通过对应的分组编号来获取匹配的结果，<br>
所以这种功能叫做捕获分组，对应的， 这种括号叫做捕获型括号<br>
``` javascript
// javascript code
"http://www.baidu.com".match(/(\w+):\/\/(\w+\.\w+\.\w+)/);
// 会返回如下的结果
0: "http://www.baidu.com"
1: "http"
2: "www.baidu.com"
groups: undefined
// 索引0对应的就是整个匹配到的部分, 而索引1对应第一个分组, 也就是协义部分, 索引2对应着第二个分组, 也就是域名部分
```
### 非捕获分组
非捕获分组，只分组，不保留匹配结果，同时他也不会影响分组排序，因为排序的时候会忽略非捕获分组<br>
有些情况下，只想用括号将某些部分看成一个整体，临时使用，不分配编号，后续不再用<br>
通过 (?:表达式) 表示不保存分组<br>
``` javascript
// javascript code
"http://www.baidu.com".match(/(?:\w+):\/\/(\w+\.\w+\.\w+)/);
// 会返回如下的结果
0: "http://www.baidu.com"
1: "www.baidu.com"
groups: undefined
// 这次没有保留协义部分的匹配结果, 同时也没有影响匹配顺序
```
### 命名分组
捕获分组一般通过数组编号来引用匹配的内容，虽然是从左到右来计算编号，<br>
但是分组多了也难免混淆，因此可以采用对分组命名的方式来使分组更直观<br>
::: warning
在不同的语言语法中，命名分组的语法也不一样
:::
``` javascript
// javascript 语法
(?<name>)
// php 语法
(?<name>) 或者 (?P<name>) 或 (?'name')
```
``` javascript
// javascript code
"http://www.baidu.com".match(/(?<protocol>\w+):\/\/(?<domain>\w+\.\w+\.\w+)/);
// 返回结果
0: "http://www.baidu.com"
1: "http"
2: "www.baidu.com"
groups:
    domain: "www.baidu.com"
    protocol: "http"
```

### 分组引用
当一个正则表达式被分组后，每个组将会自动的分配一个组号用于代表该组的表达式，<br>
其中，组号的编制规则为：从左到右、以分组的左括号“(”为标志，<br>
第一个分组的组号为1，第二个分组的组号为2，以此类推。<br>
::: warning
在不同的语言语法中，分组引用的语法也不一样
:::
知道分组编号后，我们会需要引用分组，引用规则如下：<br>
``` javascript
// javascript 语法
查找时：$number 替换时：$number
// java 语法
查找时：\number 替换时：$number
```
``` javascript
// 使用数字来引用分组
\b(\w+)\b\s+\1\b
// 可以用来匹配重复的单词，像go go, 或者kitty kitty。
// 这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(\b(\w+)\b)，这个单词会被捕获到编号为1的分组中，
// 然后是1个或几个空白符(\s+)，最后是分组1中捕获的内容（也就是前面匹配的那个单词）(\1)。
----------------------------------------------
// 使用组名来引用分组
\b(?<Word>\w+)\b\s+\k<Word>\b
```
::: details 代码实例解析
Java中对分组的引用<br>
``` java
String s = "023-81200222、024-81200223、123-81200224";
Pattern pattern = Pattern.compile("(0\\d{1,})-(\\d{1,})");
Matcher matcher = pattern.matcher(s);
matcher.find();
System.out.println(matcher.group(0));
System.out.println(matcher.group(1));
System.out.println(matcher.group(2));
// 运行结果：
//   023-81200222
//   023
//   81200222
```
:::
## 环视（零宽断言）
环视，在不同的地方又称之为零宽断言，简称断言。 <br>
环视强调的是它所在的位置，前面或者后面，必须满足环视表达式中的匹配情况，才能匹配成功。 <br>
环视可以认为是虚拟加入到它所在位置的附加判断条件，并不消耗正则的匹配字符。<br>
### 环视语法
| 表达式 | 名称 | 含义 | 实例 |
|:-:|-|-|-|
| (?<=Y) | 肯定逆序环视 | 左边是Y | (?<=\d)th -> 代表左边是一个数字的th，例如9th |
| (?<!Y) | 否定逆序环视 | 左边不是Y | (?<=!\d)th -> 代表左边不是一个数字的th，例如health |
| (?=Y) | 肯定顺序环视 | 右边是Y | six(?=\d) -> 代表右边是一个数字的six，例如six6 |
| (?!Y) | 否定顺序环视 | 右边不是Y | hi(?!\d) -> 代表右边不是一个数字的hi，例如high |
::: danger
记忆口诀：< 看左边，没有 < 看右边，感叹号是非的意思
:::
### 环视的用法
::: details 代码实例解析
正则分块组合法-必须包含字母、数字、特殊字符<br>
``` javascript
正则：
    ^(?=.*?[a-z])(?=.*?\d)(?![a-z\d]+$).+$ 
解析： 
    (?=.*?[a-z])限制必须有字母 
    (?=.*?\d)限制必须有数字 
    (?![a-z\d]+$)限制从开头到结尾不能全为数字和字母 
    .+在没有限定的情况下可以是任意字符 
    ^和$ 限定字符串的开头和结尾 
    组合起来就可以得到上面正则。
```
正则逐步完善法-排除特定标签p/a/img，匹配html标签<br>
``` javascript
正则：</?(?!p|a|img)([^> /]+)[^>]*/?>  
```
:::
## 贪婪模式、非贪婪模式与独占模式
* 贪婪模式，表示数量的限定符，默认都是贪婪的，简单说就是尽可能进行最长匹配，需要回溯才能完成相应的功能
* 非贪婪模式，表示数量的限定符后加上?，表示非贪婪的，则会尽可能进行最短匹配，需要回溯才能完成相应的功能
* 独占模式：表示数量的限定符后加上+，它类似贪婪匹配，但匹配过程不会发生回溯，因此在一些场合下性能会更好
   * 如果匹配失败就结束，不会进行回溯，这样的话就比较节省时间 
::: danger
不是所有语言都支持独占模式，Python 和 Go 的标准库目前都不支持独占模式
:::

| 模式 | 语法 |  正则 | 文本 | 结果 |
|:-:|:-:|-|-|-|
| 贪婪模式 |  | a{1,3}ab | aaab | 匹配 |
| 非贪婪模式 | ? | a{1,3}?ab | aaab | 匹配 |
| 独占模式 | + | a{1,3}+ab | aaab | 不匹配 |
※ 分析：a{1,3}+已尽力去配了aaa，因为不回溯，所以没有匹配上后面的ab<br>
## 注释
``` java
// 语法
(?#comment)
// 例如
2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)
```
要包含注释的话，最好是启用“忽略模式里的空白符”选项，<br>
这样在编写表达式时能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略。<br>
启用这个选项后，在#后面到这一行结束的所有文本都将被当成注释忽略掉。<br>
例如，我们可以前面的一个表达式写成这样：<br>
``` java
(?<=    # 断言要匹配的文本的前缀
<(\w+)> # 查找尖括号括起来的内容
        # (即HTML/XML标签)
)       # 前缀结束
.*      # 匹配任意文本
(?=     # 断言要匹配的文本的后缀
<\/\1>  # 查找尖括号括起来的内容
        # 查找尖括号括起来的内容
)       # 后缀结束
```
## 处理选项
| 名称 | 意义 | 说明 |
|:-:|-|-|
| IgnoreCase | 忽略大小写 | 匹配时不区分大小写。 |
| Multiline | 多行模式 | 更改^和$的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。<br>在此模式下, $ 的精确含意是:匹配 \n 之前的位置以及字符串结束前的位置 |
| Singleline | 单行模式 | 更改 . 的含义，使它与每一个字符匹配（包括换行符\n）。 |
| IgnorePatternWhitespace | 忽略空白 | 忽略表达式中的非转义空白并启用由#标记的注释。 |
| ExplicitCapture | 显式捕获 | 仅捕获已被显式命名的组。 |
::: warning
不同的开发语言，对应的处理选项可能不同，请注意
:::
``` javascript
// javascript
Regex regex = new Regex(@"\ba\w{6}\b", RegexOptions.IgnoreCase);
// java
Pattern pat = Pattern.compile(regEx, Pattern.CASE_INSENSITIVE);
```
## 平衡组
平衡组，故名思义，平衡即对称，主要是结合几种正则语法规则，提供对配对出现的嵌套结构的匹配。<br>
如果想要匹配可嵌套的层次性结构的话，就得使用平衡组了。<br>
::: warning
平衡组并不是所有程序语言都支持，PHP语言就不支持
:::
| 语法 | 说明 |
|:-:|-|
| (?\<group\>) | 把捕获的内容命名为group，并压入堆栈 |
| (?\<\-group\>) | 从堆栈上弹出最后压入堆栈的名为group的捕获内容，如果堆栈本来为空，则本分组的匹配失败 |
| (?(group)yes\|no) | 如果堆栈上存在以名为group的捕获内容的话，继续匹配yes部分的表达式，否则继续匹配no部分 |
| (?!) | 顺序否定环视，由于没有后缀表达式，试图匹配总是失败 |
``` java
需求说明：匹配成对出现的()中的内容
源字符串：a+(b*(c+d))/e+f-(g/(h-i))*j
正则表达式：((?<Open>\()|(?<−Open>)|[^()])*(?(Open)(?!))\)
输出结果：(b*(c+d)) 和 (g/(h-i))
说明：
 \(               #普通字符“(”
   (              #分组构造，用来限定量词“*”修饰范围
     (?<Open>\()  #命名捕获组，遇到开括弧“Open”计数加1
     |            #分支结构
     (?<-Open>\)) #狭义平衡组，遇到闭括弧“Open”计数减1
     |            #分支结构
     [^()]+       #非括弧的其它任意字符
   )*             #以上子串出现0次或任意多次
   (?(Open)(?!))  #判断是否还有“Open”，有则说明不配对，什么都不匹配
 \)               #普通闭括弧
```
## 模式修饰符
| 语法 | 说明 |
|:-:|-|
| /g | 表示该表达式将用来在输入字符串中查找所有可能的匹配，返回的结果可以是多个。<br>如果不加/g最多只会匹配一个 |
| /i | 表示匹配的时候不区分大小写，这个跟其它语言的正则用法相同 |
| /m | 表示多行匹配。什么是多行匹配呢？就是匹配换行符两端的潜在匹配。影响正则中的^$符号 |
| /s | 与/m相对，单行模式匹配。 |
| /e | 可执行模式，此为PHP专有参数，例如preg_replace函数。 |
| /x | 忽略空白模式。 |
::: warning
模式修饰符可以同时使用
:::
``` java
/[a-z0-9]/i，表示匹配字母数字，不区分大小写。
```
## 高级说明
### 按单字符匹配
正则里面的数据都是按照单个字符来进行匹配的<br>
比如，我要匹配0-15的数值区间，用正则来写的话，便是[0-9]|1[0-5]，<br>
这里，便是把0-9这种单字符的情况，和10-15这种多字符的情况拆分开了，使用分支|来区分开，表示要么是0-9，要么是10-15。<br>
``` java
现在延伸至1-65535，我个人的处理思想是从大到小，一块块分解：
1. 65530-65535  ==>  6553[0-5]          末位区间0-5
2. 65500-65529  ==>  655[0-2][0-9]      第四位区间0-2，末位区间0-9
3. 65000-65499  ==>  65[0-4][0-9]{2}    第三位区间0-4，后两位0-9
4. 60000-64999  ==>  6[0-4][0-9]{3}     第二位区间0-4，后三位0-9
5. 10000-59999  ==>  [1-5][0-9]{4}      第一位区间1-5，后四位0-9
6. 1-9999       ==>  [1-9][0-9]{0,3}    第一位只能是1-9，后三位可有可无
最后组合起来：
(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3})
便得到1-65535匹配正则
```
### 正则表达式工具
#### RegexBuddy
参照说明：http://www.zjmainstay.cn/regex-tool-regexbuddy
### 正则三段论应用
正则三段论：定锚点，去噪点，取数据<br>
``` java
需求 -> 匹配作者名字
源数据 -> 标题：深入正则表达式应用，作者：Zjmainstay
(1) 定锚点：作者：
(2) 去噪点：标题：等就是没用的数据，不需要考虑到正则中
(3) 取数据：确定正则表达式为 -> 作者：(.*)
```
``` java
需求 -> 提取链接和标题，还有a标签的文字
源数据 -> <a href="http://www.zjmainstay.cn/my-regexp" class="demo8" title="正则三段论应用举例">正则表达式入门教程</a>
(1) 定锚点：
我们必须定位好锚点，主要有：
   1. <a //必须是a标签
   2. href=" 和 " //href=""的内容得到链接
   3. title=" 和 " //title=""的内容得到标题
   4. > 和 </a> //>和</a>的内容得到标签文字
(2) 去噪点：
   除了锚点，其他的都是噪点，使用.*?替代
(3) 取数据：
   提取的数据部分使用括号获取子模式，得到分组数据，因此得到正则：<a href="(.*?)".*?title="(.*?)">(.*?)</a>
```
## Java 正则表达式
### String 类
* public String[] split(String regex)
   * 根据给定的正则表达式的匹配来拆分此字符串。
   * 例如：将字符串 "boo:and:foo" , 用 : 来分拆，得到如下结果：{ "boo", "and", "foo" }
* public String[] split(String regex, int limit)
   * 根据匹配给定的正则表达式来拆分limit次此字符串。
   * 例如：将字符串 "boo:and:foo" , 用 : 来分拆 2 次，{ "boo", "and:foo" }
      * 如果该限制 n 大于 0，则模式将被最多应用 n - 1 次，数组的长度将不会大于 n，而且数组的最后项将包含超出最后匹配的定界符的所有输入。
      * 如果 n 为非正，则模式将被应用尽可能多的次数，而且数组可以是任意长度。
      * 如果 n 为零，则模式将被应用尽可能多的次数，数组可有任何长度，并且结尾空字符串将被丢弃。
* public String replaceAll(String regex, String replacement)
   * 使用给定的 replacement 字符串替换此字符串匹配给定的正则表达式的每个子字符串。
* public String replaceFirst(String regex, String replacement)
   * 使用给定的 replacement 字符串替换此字符串匹配给定的正则表达式的第一个子字符串。
### MatchResult 类
匹配操作的结果。<br>
此接口包含用于确定与正则表达式匹配结果的查询方法。<br>
通过 MatchResult 可以查看匹配边界、组和组边界，但是不能修改<br>
### Matcher 类
通过解释 Pattern 对 字符序列 执行匹配操作的引擎。<br>
* matcher 方法
   * 从模式创建匹配器。创建匹配器后，可以使用它执行三种不同的匹配操作：
* matches 方法
   * 尝试将整个输入序列与该模式匹配。
* lookingAt 方法
   * 尝试将输入序列从头开始与该模式匹配。
* find 方法
   * 扫描输入序列以查找与该模式匹配的下一个子序列。
### Pattern 类
正则表达式的编译表示形式。<br>
指定为字符串的正则表达式必须首先被编译为此类的实例。<br>
然后，可将得到的模式用于创建 Matcher 对象，依照正则表达式，该对象可以与任意字符序列匹配。<br>
执行匹配所涉及的所有状态都驻留在匹配器中，所以多个匹配器可以共享同一模式。<br>
::: details 代码实例解析
``` java
public static void main(String[] args) {
    // 要验证的字符串
    String str = "baike.xsoftlab.net";
    // 正则表达式规则
    String regEx = "baike.*";
    // 编译正则表达式
    Pattern pattern = Pattern.compile(regEx);
    // 忽略大小写的写法
    // Pattern pat = Pattern.compile(regEx, Pattern.CASE_INSENSITIVE);
    Matcher matcher = pattern.matcher(str);
    // 查找字符串中是否有匹配正则表达式的字符/字符串
    boolean rs = matcher.find();
    System.out.println(rs);
    // 输出结果：true
}
```
:::
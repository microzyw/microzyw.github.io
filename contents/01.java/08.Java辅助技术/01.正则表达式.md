# 正则表达式
::: tip
本文主要对正则表达式进行总结。@Frank Zhao
:::
## 本章目录
[[toc]]
## 概述
正则表达式用于定义一个搜索模式的字符串。<br>
正则表达式可以用于搜索、编辑和操作文本。<br>
正则表达式应用的是文本字符串，它会以定义的模式从左到右匹配文本，每个源字符只匹配一次。<br><br>
<img src="/images/java/1896874-20200701140224149-1020851468.png" width="50%" height="50%" /><br>

## 基本语法
| 符号 | 说明 |
|:-:|-|
| <b>XZ</b> | 匹配 X 后直接跟着 Z |
## 正则元字符
### 基本字符
| 符号 | 说明 |
|:-:|-|
| <b>.</b> | 匹配任意单个字符，除了换行符（Linux 中换行是 \n，Windows 中换行是 \r\n）<br>※ 如果需要匹配包括换行的任意字符，可以使用 [\\s\\S] 代替. |
| <b>^</b> | 匹配字符串开头 |
| <b>$</b> | 匹配字符串结尾 |
### 范围字符
| 符号 | 说明 |
|:-:|-|
| <b>[]</b> | 多选一，匹配内部任意单个字符，参照 [abc] 等的说明<br>[] 里面的特殊字符有五个：[ ] - \\ ^，其他字符都是普通字符，包括 * . ? \ \| 等都是普通字符。<br>关于 [] 常见的错误用法是：<br>&nbsp;&nbsp;&nbsp;&nbsp;[ab\|bc]用来表示ab或bc，实际上，它得到的结果是[abc\|]，即a或b或c或\|这4个字符（单字符）的任意一个。<br>&nbsp;&nbsp;&nbsp;&nbsp;正确的应该写成(ab\|bc)。 |
| <b>[abc]</b> | 复选集定义，匹配字母 a 或 b 或 c |
| <b>[abc][vz]</b> | 复选集定义，匹配字母 a 或 b 或 c，后面跟着 v 或 z |
| <b>[^abc]</b> | 当插入符 ^ 在中括号中以第一个字符开始显示，则表示否定模式。此模式匹配所有字符，除了 a 或 b 或 c |
| <b>[a-d1-7]</b> | 范围匹配，匹配字母 a 到 d 和数字从 1 到 7 之间 |
| <b>[a-z]</b> | 字符范围内匹配，匹配指定范围内的任意字符。<br>例如，[a-z]可以匹配a到z范围内的任意小写字母字符。 |
| <b>[^a-z]</b> | 字符范围外匹配，匹配指定范围外的任意字符。<br>例如，[^a-z]可以匹配a到z范围外的任意小写字母字符。 |
| <b>\|</b> | 或，用于匹配多个字符中的一个 |
| <b>X\|Z</b> | 匹配 X 或 Z |
| <b>()</b> | 子表达式，可以在正则表达式中再嵌套一个子正则表达式 |
### 特殊字符
| 符号 | 说明 |
|:-:|-|
| <b>\d</b> | 匹配一个数字，是 [0-9] 的简写 |
| <b>\D</b> | 匹配一个非数字，是 [^0-9] 的简写 |
| <b>\s</b> | 匹配所有的空白字符，包括空格、制表符、换页符、换行符、回车符 等等。等价于[ \t\f\n\r ]。<br>[\\s\\S]表示匹配任意字符 |
| <b>\S</b> | 匹配所有的非空白字符 |
| <b>\w</b> | 匹配一个单词字符（大小写字母、数字、下划线），是 [a-zA-Z_0-9] 的简写 |
| <b>\W</b> | 匹配一个非单词字符（除了大小写字母、数字、下划线之外的字符），等同于 [^\w] |
| <b>\b</b> | 匹配单词的开始或结束，表示单词边界<br>例如：\ba\w*\b匹配以字母a开头的单词(\ba)，然后是任意数量的字母或数字(\w*)，最后是单词结束处(\b)<br>※ 不匹配任何字符，它只匹配一个位置（开头，结尾） |
| <b>\B</b> | 表示非单词边界 |
### 空白字符
| 符号 | 说明 |
|:-:|-|
| <b>\r</b> | 回车符 |
| <b>\n</b> | 换行符 |
| <b>\f</b> | 换页符 |
| <b>\t</b> | 制表符 |
* 不同系统在每行文本结束位置会有换行符，但不同系统的换行符会不一样
   * Windows \r\n
   * Linux   \n
   * macOS   \n
* 在正则中，也可以直接使用 \r 、 \n 来匹配对应的空白符
* 当然， \s 已经可以满足大部分空白符场景，它代表任意单个空白符，相当于 [\r\n\t\f] 空白符集合
### 限定符
| 符号 | 说明 |
|:-:|-|
| <b>*</b> | 匹配 >=0 个，是 {0,} 的简写<br>例如：X* 表示匹配零个或多个字母 X，.* 表示匹配任何字符串 |
| <b>+</b> | 匹配 >=1 个，是 {1,} 的简写<br>例如：X+ 表示匹配一个或多个字母 X |
| <b>?</b> | 匹配 1 个或 0 个，是 {0,1} 的简写<br>例如：X? 表示匹配 0 个或 1 个字母 X |
| <b>{X}</b> | 只匹配 X 个字符<br>例如：\d{3} 表示匹配 3 个数字，.{10} 表示匹配任何长度是 10 的字符串 |
| <b>{X,}</b> | 匹配 >=X<br>例如：\d{1,} 表示匹配至少 1 个数字 |
| <b>{X,Y}</b> | 匹配 >=X 且 <=Y 个<br>例如：\d{1,4} 表示匹配至少 1 个最多 4 个数字 |
### 转义字符
| 符号 | 说明 |
|:-:|-|
| <b>\\</b> | 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。<br>例如：'\n' 匹配换行符\n。序列 '\\\\' 匹配 "\\"，而 '\\(' 则匹配 "("。<br>例如：deerchao\\.cn匹配deerchao.cn，C:\\\\Windows匹配C:\Windows。 |
::: details 简单的正则表达式实例
实例一 <br>
``` java
String s = "abcde\\n";
Pattern pattern = Pattern.compile(".");
Matcher matcher = pattern.matcher(s);
while (matcher.find()) {
    System.out.print(matcher.group());
    System.out.print("、");
}
// 运行结果：a、b、c、d、e、\、n、
```
实例二 <br>
``` java
String s = "0198aAzZ\\w哎_-";
Pattern pattern = Pattern.compile("\\w");
Matcher matcher = pattern.matcher(s);
while (matcher.find()) {
    System.out.print(matcher.group());
    System.out.print("、");
}
// 运行结果：0、1、9、8、a、A、z、Z、w、_、
```
实例三 <br>
``` java
String s = "023-81200222、023-81200223、023-81200224";
Pattern pattern = Pattern.compile("0\\d{1,}-\\d{1,}");
Matcher matcher = pattern.matcher(s);
while (matcher.find()) {
    System.out.print(matcher.group());
    System.out.print("、");
}
// 运行结果：023-81200222、023-81200223、023-81200224、
```
:::
## 分组
在一个正则表达式中, 通过英文 () 包裹的子表达式内容, 就对应着一个分组<br>
正则表达式中的分组又称为子表达式，就是把一个正则表达式的全部或部分当做一个整体进行处理，分成一个或多个组。<br>
### 分组的编号规则
第几个括号就是第几个分组<br>
整个正则表达式所匹配到的文本, 就对应着分组0, 而我们显示指定的分组, 都是从1开始排序的<br>
例如下图这个表达式由两个子表达式组成，第一个分组是日期，第二个分组是时间<br>
<br>
<img src="/images/java/1896874.png" width="50%" height="50%" />

### 分组的嵌套
无论括号如何嵌套，分组的编号都是根据开括号出现顺序来计数的；<br>
开括号是从左向右数起第多少个开括号，整个括号分组的编号就是多少<br>
<br>
<img src="/images/java/b3177d1c440897afb425ecc923ade6e6.png" width="40%" height="30%" />
<br>

### 捕获分组
括号不仅能把元素进行分组，当正则表达式匹配完成之后，还会保留分组匹配的结果，<br>
所以在匹配完成之后，可以通过对应的分组编号来获取匹配的结果，<br>
所以这种功能叫做捕获分组，对应的， 这种括号叫做捕获型括号<br>
``` javascript
// javascript code
"http://www.baidu.com".match(/(\w+):\/\/(\w+\.\w+\.\w+)/);
// 会返回如下的结果
0: "http://www.baidu.com"
1: "http"
2: "www.baidu.com"
groups: undefined
// 索引0对应的就是整个匹配到的部分, 而索引1对应第一个分组, 也就是协义部分, 索引2对应着第二个分组, 也就是域名部分
```
### 非捕获分组
非捕获分组，只分组，不保留匹配结果，同时他也不会影响分组排序，因为排序的时候会忽略非捕获分组<br>
有些情况下，只想用括号将某些部分看成一个整体，临时使用，不分配编号，后续不再用<br>
通过 (?:表达式) 表示不保存分组<br>
``` javascript
// javascript code
"http://www.baidu.com".match(/(?:\w+):\/\/(\w+\.\w+\.\w+)/);
// 会返回如下的结果
0: "http://www.baidu.com"
1: "www.baidu.com"
groups: undefined
// 这次没有保留协义部分的匹配结果, 同时也没有影响匹配顺序
```
### 命名分组
捕获分组一般通过数组编号来引用匹配的内容，虽然是从左到右来计算编号，<br>
但是分组多了也难免混淆，因此可以采用对分组命名的方式来使分组更直观<br>
::: warning
在不同的语言语法中，命名分组的语法也不一样
:::
``` javascript
// javascript 语法
(?<name>)
// php 语法
(?<name>) 或者 (?P<name>) 或 (?'name')
```
``` javascript
// javascript code
"http://www.baidu.com".match(/(?<protocol>\w+):\/\/(?<domain>\w+\.\w+\.\w+)/);
// 返回结果
0: "http://www.baidu.com"
1: "http"
2: "www.baidu.com"
groups:
    domain: "www.baidu.com"
    protocol: "http"
```

### 分组引用
当一个正则表达式被分组后，每个组将会自动的分配一个组号用于代表该组的表达式，<br>
其中，组号的编制规则为：从左到右、以分组的左括号“(”为标志，<br>
第一个分组的组号为1，第二个分组的组号为2，以此类推。<br>
知道分组编号后，我们会需要引用分组，引用规则如下：<br>
::: warning
在不同的语言语法中，分组引用的语法也不一样
:::
``` javascript
// javascript 语法
查找时：$number 替换时：$number
// java 语法
查找时：\number 替换时：$number
```
``` java
String s = "023-81200222、024-81200223、123-81200224";
Pattern pattern = Pattern.compile("(0\\d{1,})-(\\d{1,})");
Matcher matcher = pattern.matcher(s);
matcher.find();
System.out.println(matcher.group(0));
System.out.println(matcher.group(1));
System.out.println(matcher.group(2));
// 运行结果：
//   023-81200222
//   023
//   81200222
```
## 环视（零宽断言）
环视，在不同的地方又称之为零宽断言，简称断言。 <br>
环视强调的是它所在的位置，前面或者后面，必须满足环视表达式中的匹配情况，才能匹配成功。 <br>
环视可以认为是虚拟加入到它所在位置的附加判断条件，并不消耗正则的匹配字符。<br>
### 环视语法
| 表达式 | 名称 | 含义 | 实例 |
|:-:|-|-|-|
| (?<=Y) | 肯定逆序环视 | 左边是Y | (?<=\d)th -> 代表左边是一个数字的th，例如9th |
| (?<!Y) | 否定逆序环视 | 左边不是Y | (?<=!\d)th -> 代表左边不是一个数字的th，例如health |
| (?=Y) | 肯定顺序环视 | 右边是Y | six(?=\d) -> 代表右边是一个数字的six，例如six6 |
| (?!Y) | 否定顺序环视 | 右边不是Y | hi(?!\d) -> 代表右边不是一个数字的hi，例如high |
::: danger
记忆口诀：< 看左边，没有 < 看右边，感叹号是非的意思
:::
### 环视的用法
::: details 代码实例解析
正则分块组合法-必须包含字母、数字、特殊字符<br>
``` javascript
正则：
    ^(?=.*?[a-z])(?=.*?\d)(?![a-z\d]+$).+$ 
解析： 
    (?=.*?[a-z])限制必须有字母 
    (?=.*?\d)限制必须有数字 
    (?![a-z\d]+$)限制从开头到结尾不能全为数字和字母 
    .+在没有限定的情况下可以是任意字符 
    ^和$ 限定字符串的开头和结尾 
    组合起来就可以得到上面正则。
```
正则逐步完善法-排除特定标签p/a/img，匹配html标签<br>
``` javascript
正则：</?(?!p|a|img)([^> /]+)[^>]*/?>  
```
:::
## 贪婪模式、非贪婪模式与独占模式
* 贪婪模式，表示数量的限定符，默认都是贪婪的，简单说就是尽可能进行最长匹配，需要回溯才能完成相应的功能
* 非贪婪模式，表示数量的限定符后加上?，表示非贪婪的，则会尽可能进行最短匹配，需要回溯才能完成相应的功能
* 独占模式：表示数量的限定符后加上+，它类似贪婪匹配，但匹配过程不会发生回溯，因此在一些场合下性能会更好
   * 如果匹配失败就结束，不会进行回溯，这样的话就比较节省时间 
::: danger
不是所有语言都支持独占模式，Python 和 Go 的标准库目前都不支持独占模式
:::

| 模式 | 语法 |  正则 | 文本 | 结果 |
|:-:|:-:|-|-|-|
| 贪婪模式 |  | a{1,3}ab | aaab | 匹配 |
| 非贪婪模式 | ? | a{1,3}?ab | aaab | 匹配 |
| 独占模式 | + | a{1,3}+ab | aaab | 不匹配 |
※ 分析：a{1,3}+已尽力去配了aaa，因为不回溯，所以没有匹配上后面的ab<br>
## 注释
``` java
// 语法
(?#comment)
// 例如
2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)
```
## Java 正则表达式
### String 类
* public String[] split(String regex)
   * 根据给定的正则表达式的匹配来拆分此字符串。
   * 例如：将字符串 "boo:and:foo" , 用 : 来分拆，得到如下结果：{ "boo", "and", "foo" }
* public String[] split(String regex, int limit)
   * 根据匹配给定的正则表达式来拆分limit次此字符串。
   * 例如：将字符串 "boo:and:foo" , 用 : 来分拆 2 次，{ "boo", "and:foo" }
      * 如果该限制 n 大于 0，则模式将被最多应用 n - 1 次，数组的长度将不会大于 n，而且数组的最后项将包含超出最后匹配的定界符的所有输入。
      * 如果 n 为非正，则模式将被应用尽可能多的次数，而且数组可以是任意长度。
      * 如果 n 为零，则模式将被应用尽可能多的次数，数组可有任何长度，并且结尾空字符串将被丢弃。
* public String replaceAll(String regex, String replacement)
   * 使用给定的 replacement 字符串替换此字符串匹配给定的正则表达式的每个子字符串。
* public String replaceFirst(String regex, String replacement)
   * 使用给定的 replacement 字符串替换此字符串匹配给定的正则表达式的第一个子字符串。
### MatchResult 类
匹配操作的结果。<br>
此接口包含用于确定与正则表达式匹配结果的查询方法。<br>
通过 MatchResult 可以查看匹配边界、组和组边界，但是不能修改<br>
### Matcher 类
通过解释 Pattern 对 字符序列 执行匹配操作的引擎。<br>
* matcher 方法
   * 从模式创建匹配器。创建匹配器后，可以使用它执行三种不同的匹配操作：
* matches 方法
   * 尝试将整个输入序列与该模式匹配。
* lookingAt 方法
   * 尝试将输入序列从头开始与该模式匹配。
* find 方法
   * 扫描输入序列以查找与该模式匹配的下一个子序列。
### Pattern 类
正则表达式的编译表示形式。<br>
指定为字符串的正则表达式必须首先被编译为此类的实例。<br>
然后，可将得到的模式用于创建 Matcher 对象，依照正则表达式，该对象可以与任意字符序列匹配。<br>
执行匹配所涉及的所有状态都驻留在匹配器中，所以多个匹配器可以共享同一模式。<br>
::: details 代码实例解析
``` java
public static void main(String[] args) {
    // 要验证的字符串
    String str = "baike.xsoftlab.net";
    // 正则表达式规则
    String regEx = "baike.*";
    // 编译正则表达式
    Pattern pattern = Pattern.compile(regEx);
    // 忽略大小写的写法
    // Pattern pat = Pattern.compile(regEx, Pattern.CASE_INSENSITIVE);
    Matcher matcher = pattern.matcher(str);
    // 查找字符串中是否有匹配正则表达式的字符/字符串
    boolean rs = matcher.find();
    System.out.println(rs);
    // 输出结果：true
}
```
:::
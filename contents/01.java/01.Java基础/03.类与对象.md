# 类与对象
::: tip
本文主要对Java的类与对象进行总结。@Frank Zhao
:::
## 本章目录
[[toc]]
## 类
Java中的全部内部必须放在类中 <br>
* 类名的定义规则
   * 类名必须以字母开头，后面可以跟字母和数字的任意组合
   * 类名以大写字母开头，每个单词的第一个字母大写
   * 长度基本上没有限制
   * 不能使用Java保留字
   * 源代码的文件名必须与公有类的名字相同，并以.java作为扩展名
::: warning
在一个源文件中，只能有一个共有类，但是可以有任意数目的非共有类
:::
## 构造方法
* 引入构造方法的原因
   * 保证每个新创建的对象处于正常合理以及所希望的状态
   * 引入灵活性，满足各种复杂操作的需要
* 构造器与类同名
* 每个类可以有一个或多个构造器
* 构造器没有返回值，可以有任意个参数
* 构造器总是伴随着new操作符的执行被调用，而不能对一个已存在的对象调用构造器来重新设置实例域
* 构造器可以调用其他构造器，用this
::: warning
* 不要在构造方法中定义与实例域重名的局部变量
:::
### 默认构造方法
* 若没有构造器，系统会自动生成一个无参构造方法，也叫默认构造方法
   * 当类中没有构造器时，系统才会自动提供一个默认构造器，否则不会提供
   * 若类中有个非默认构造器，如果还需要使用默认构造器，那么必须显式的定义出默认构造器
## 实例域
::: warning
* 如果在构造器中没有显示地给属性赋值，那么会被自动地赋值为默认值
   * 数值为0
   * 布尔值为false
   * 对象引用为null
:::
## 方法
### main 方法
* 每一个Java应用程序都有一个带String[] args参数的main方法
   * main方法必须声明为public
   * 这个参数表明main方法将接收一个字符串数组，也就是命令行参数
## 方法参数
### 参数调用方式
::: warning
* Java参数使用的是值传递，不是引用传递，方法得到的是所有参数的一个拷贝
   * 方法体内无法直接修改基本数据类型参数的值，也无法直接修改可变类对象的引用地址，
   * 可以通过可变类对象的变更器对里面的内容域的值进行修改
:::
::: details 代码实例解析
以下代码中 Dog dog 的 dog 是一个指针，存储的是对象的地址。<br>
在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。<br>
因此在方法中改变指针引用的对象，那么这两个指针此时指向的是完全不同的对象，一方改变其所指向对象的内容对另一方没有影响。<br>
``` java
public class Dog {
    String name;

    Dog(String name) {
        this.name = name;
    }

    String getName() {
        return this.name;
    }

    void setName(String name) {
        this.name = name;
    }

    String getObjectAddress() {
        return super.toString();
    }
}

public class PassByValueExample {
    public static void main(String[] args) {
        Dog dog = new Dog("A");
        System.out.println(dog.getObjectAddress()); // Dog@4554617c
        func(dog);
        System.out.println(dog.getObjectAddress()); // Dog@4554617c
        System.out.println(dog.getName());          // A
    }

    private static void func(Dog dog) {
        System.out.println(dog.getObjectAddress()); // Dog@4554617c
        dog = new Dog("B");
        System.out.println(dog.getObjectAddress()); // Dog@74a14482
        System.out.println(dog.getName());          // B
    }
}
```
但是如果在方法中改变对象的字段值会改变原对象该字段值，因为改变的是同一个地址指向的内容。<br>
``` java
class PassByValueExample {
    public static void main(String[] args) {
        Dog dog = new Dog("A");
        func(dog);
        System.out.println(dog.getName());          // B
    }

    private static void func(Dog dog) {
        dog.setName("B");
    }
}
```
:::
### 可变数量参数
可以传递若干个以逗号分隔的值
``` java
Double max(double… values)
```
::: warning
允许将数组作为最后一个参数，传递进可变参数中
:::
## 包
使用包的主要原因是确保类名的唯一性 <br>
* 类放入包中
``` java
package 语句
```
::: warning
必须将包的名字放在源文件的开头
:::
* 类的导入
``` java
import 语句
```
::: danger
星号（*）只能导入一个包（目录），不能导入多级目录
:::
## 块作用域
* 块是指由一对花括号括起来的若干条简单的Java语句
   * 一个块可以嵌套在另一个块中
   * 不能在嵌套的两个块中声明同名的变量
``` java
{

}
```
### 初始化块
* 在类中定义的块作用域被称为初始化块
   * 只要构造类的对象，初始化块就会被执行，无论它是在类的最前还是最后
   * 在一个类的声明中，可以包含多个初始化块
## 对象析构器
Java具有自动垃圾回收器，不需要人工回收内存，所以Java不支持对象析构器
## finalize方法
finalize方法将在垃圾回收器清除对象之前被调用<br>
还有一种“关闭钩”，Runtime.addShutdownHook，也能在垃圾回收器清除对象之前被调用
## static
### 静态域 
* 静态域，被定义为static的实例域，每个类中只有一个静态域<br>
   * 每个该类的对象都有自己的一份拷贝，也就是共享该静态域<br>
   * 静态域属于类，而不属于任何其对象<br>
   * 在类第一次加载的时候，将会进行静态域的初始化<br>
### 静态初始化器
静态初始化器是对类进行初始化，而构造方法是对类的对象进行初始化<br>
静态初始化器是在其所属的类导入内存时被调用，构造方法是在用new创建对象时被调用<br>
静态初始化器是一组语句，构造方法是特殊的方法<br>
``` java
static { 

}
```
### 静态方法
静态方法是不能对类进行操作的，不能操作对象，不能访问实例域，即内部不能使用this<br>
静态方法可以访问类中的静态域<br>
静态方法是随着类的创建而创建的<br>
静态方法不能操作对象，但是对象可以操作静态方法<br>
静态方法的常见用途：工厂类Factory<br>
## final
* 被final修饰的类是不能被继承的，例如String
* 被final修饰的方法是不能被子类覆盖的，可以被子类继承
* 被final修饰的基本数据类型，则该引用为常量，该值无法修改
* 被final修饰的引用数据类型，比如对象、数组等，可以修改该对象、数组的值，但指向该对象或数组的地址的引用不能修改。
::: warning
* 被final修饰的实例域，则必须当场赋值，否则编译会报错，并且后面的操作不能对它进行修改
:::
::: warning
* 对可变的类使用final修饰符可能会造成混乱，例如private final Date hireDate; 
* 仅仅意味着存储在hireDate变量中的对象引用在对象构造之后不能被改变，而并不意味着hireDate对象是一个常量，
* 因为任何方法都可以通过该Date对象的setTime更改器对其进行修改。
:::
## 抽象类
出于组织层次的需要，利用抽象类作为派生其他类的基类，而不作为具体的对象使用<br>
抽象方法充当占位的角色，不需要实现，具体的实现在子类中<br>
包含一个或多个抽象方法的类必须被声明为抽象类<br>
抽象类中可以包含具体的属性和具体的方法<br>
即使不包含抽象方法，也可以被定义为抽象类<br>
抽象类不能被实例化，可以创建对象，但是只能引用非抽象子类的对象。<br>
## 接口
接口不是类，而是一组对类的需求描述<br>
接口中只能定义静态常量和抽象方法，不能在接口中实现方法<br>
实现接口implements ，可以实现多个接口<br>
在实现接口时，必须把方法声明为public<br>
继承了接口的类必须按照接口中定义的方法来实现，必须覆盖所有方法<br>
接口之间可以继承，且可以多重继承<br>
接口不是类，不能实例化一个接口，但是可以声明接口变量，但必须引用实现了该接口的类的对象<br>
::: warning
接口中的所有方法自动地设为public，属性自动地设为public static final
:::
## 内部类
* 内部类是定义在另一个类中的类<br>
* 内部类方法可以访问外部类中的私有域<br>
* 内部类可以对同一个包中的其他类隐藏起来<br>
* 内部类是一种编译器现象，与虚拟机无关<br>
   * 编译器会把内部类翻译成用$符号分隔外部类名与内部类名的常规文件，而虚拟机对此一无所知<br>
* 若内部类没有构造器，那么编译器会自动生成一个带外部类引用参数的默认构造器<br>
   * 若存在构造器，那么编译器会自动增加一个带外部类引用的参数<br>
   * 当创建内部类对象时，编译器也对自动将this引用传递给构造器<br>
``` java
public TimePrinter(TalkingClock clock) {
  Outer = clock;
}
```
### 私有内部类
只有内部类可以是私有的
### 公有内部类
引用方式：
``` java
HttpClientInfoEntity.Baseinfo baseinfo = new HttpClientInfoEntity.Baseinfo();
```
### 局部内部类
在一个方法中定义<br>
不能用public或者private，只能默认，它的作用于被限定在声明该局部类的方法中<br>
对外部世界可以完全的隐藏起来<br>
不但可以访问外部类的作用域，也可以访问作用域中的局部变量，但必须用final修饰<br>
### 匿名内部类
当想要定义一个回调函数且不想编写大量代码时，使用匿名内部类<br>
只创建一个类的一个对象，就不必为它命名了<br>
匿名类没有类名，也不能有构造器，直接将构造器参数传递给超类的构造器<br>
尤其是在内部类实现接口的时候，不能有任何的构造参数<br>
### 静态内部类
只为了把一个类隐藏，不需要内部类引用外部类的对象时使用<br>
静态内部类声明为static，不能引用外部类的对象<br>
声明在接口中的内部类，自动变为静态内部类，即自动添加static和public<br>
## Object 超类
* Object类是所有类的最终祖先
   * 可以使用Object类型的变量引用任何类型的对象
   * 只有基本类型不是对象，其他都是对象，祖先都是Object，包括数组
### equals()
判断两个对象是否具有相同的引用
::: warning
如果重新定义equals方法，那么也必须重新定义hashCode方法，而且定义必须一致（用相同的东西来判断）
:::
#### 自定义equals方法的建议
::: details 代码实例解析
``` java
public boolean equals(Object otherObject) {					
   // 检测this与otherObject是否引用同一个对象					
   if (this == otherObject) {					
      return true;					
   }					
   // 检测otherObject是否为null					
   if (otherObject == null) {					
      return false;					
   }					
   // 检测this与otherObject是否属于同一个类					
   if (this.getClass() != otherObject.getClass()) {					
      return false;					
   }					
   // 将otherObject强制转换为当前类的变量					
   XXX other = (XXX) otherObject；					
   // 对otherObject进行具体属性的判断					
   if (this.name.equals(other.name) && this.sex.equals(other.sex)) {					
      return true;					
   } else {					
      return false;					
   }					
}
```
:::


### hashCode()
散列码，每个对象都有一个默认的散列码，其值是对象的存储地址
::: warning
如果重新定义equals方法，那么也必须重新定义hashCode方法，而且定义必须一致（用相同的东西来判断）
:::
### toString()
用于返回表示对象值的字符串


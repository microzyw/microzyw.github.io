# 反射
::: tip
本文主要对Java的反射进行总结。@Frank Zhao
:::
## 本章目录
[[toc]]
## 什么是反射
* 反射机制 Reflection 是一种在运行时动态获取类的信息以及动态调用对象的方法的功能。
   * 对于任意一个类，都能够知道这个类的所有属性和方法；
   * 对于任意一个对象，都能够调用它的任意一个方法和属性；
<br>

* 反射机制的功能
   * 在运行时判断任意一个对象所属的类。
   * 在运行时构造任意一个类的对象。
   * 在运行时判断任意一个类所具有的成员变量和方法。
   * 在运行时调用任意一个对象的方法。
   * 生成动态代理。
## 反射相关的类
### Class 
Class类在java.lang包中<br>
* Class类的实例表示正在运行的Java应用程序中的类或接口<br>
   * 枚举是一种类，注释是一种接口<br>
   * 每个数组属于被映射为 Class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。<br>
   * 基本类型（boolean，byte，char，short，int，long，float，double）和关键字void也表示为 Class 对象。<br><br>
* Class 类没有公共构造方法，不能用 new 实例化
* Class 对象是在加载类时由Java虚拟机以及通过调用类加载器中的defineClass方法自动构造的。
* Class 对象用于提供类本身的信息，比如有哪些构造方法， 有哪些属性，有哪些方法。
* 手动编写的类被编译后会产生一个Class对象，其表示的是创建的类的类型信息，而且这个Class对象保存在同名.class的文件中（字节码文件）
* 每个通过关键字class标识的类，在内存中有且只有一个与之对应的Class对象来描述其类型信息，无论创建多少个实例对象，其依据的都是一个Class对象。
#### 获取Class对象的方法		
* 方法1：Class.forName("类名字符串") （注意：类名字符串必须是全称，包名+类名）		
* 方法2：类名.class		
* 方法3：实例对象.getClass()
::: details 代码实例解析
``` java
package com.escco.study;

import java.math.BigDecimal;

public class ReflectTest {

    public static void main(String[] args) throws Exception {
        // 运行结果：根据类名：class com.escco.study.Computer
        System.out.println("根据类名：" + Computer.class);
        // 运行结果：根据实例对象：class com.escco.study.Computer
        System.out.println("根据实例对象：" + new Computer().getClass());
        // 运行结果：根据类名字符串：class com.escco.study.Computer
        System.out.println("根据类名字符串：" + Class.forName("com.escco.study.Computer"));
    }

}

class Computer extends Device {
    private String brandName;

    private BigDecimal price;

    public Computer() {

    }

    public Computer(String brandName) {
        this.brandName = brandName;
    }

    public Computer(String brandName, BigDecimal price) {
        this.brandName = brandName;
        this.price = price;
    }

    public String getBrandName() {
        return brandName;
    }

    public void setBrandName(String brandName) {
        this.brandName = brandName;
    }

    public BigDecimal getPrice() {
        return price;
    }

    public void setPrice(BigDecimal price) {
        this.price = price;
    }

    @Override
    public void sayDescription() {
        System.out.println("I am a Computer");
    }

    @Override
    public String toString() {
        return "Computer [brandName=" + brandName + ", price=" + price + "]";
    }
}

abstract class Device {
    public abstract void sayDescription();
}
```
:::
#### Class API
* getName()
   * 取得类的全限定名，返回的字符串就是JVM中Class的表示格式，可以用于动态加载Class对象，例如Class.forName。
* getSimpleName()
   * 只取得类名
* getCanonicalName()
   * 返回类的包名和类名，主要用于输出（toString）或log打印，大多数情况下和getName一样，但是在内部类、数组等类型的表示形式就不同了。 
* isInterface()
   * 判断Class对象是否是一个接口 	
* getInterfaces()
   * 返回Class对象对应的类所实现的所有接口对应的Class对象数组。 	
* getSuperclass()
   * 返回Class对象对应的类所继承的直接基类。	
* newInstance()
   * 使用Class对象对应的类的无参构造方法创建对象。
   * 使用该方法创建的类，必须带有无参的构造器。
* getConstructors()
   * 获取Class对象对应的类的所有public构造方法（不包括父类） 	
* getDeclaredConstructors()
   * 获取Class对象对应的类的所有构造方法（不包括父类） 
* getConstructor(Class<?>... parameterTypes)
   * 获取Class对象对应的类的指定参数的public构造方法（不包括父类） 
* getDeclaredConstructor(Class<?>... parameterTypes)
   * 获取Class对象对应的类的指定参数的构造方法（包括private）（不包括父类）
   * 如果是private必须设置可访问 setAccessible(true);
* getFields()
   * 获取Class对象对应的类的所有public属性（包括父类） 
* getDeclaredFields()
   * 获取Class对象对应的类的所有属性（不包括父类） 
* getField(String name)
   * 获取Class对象对应的类的指定参数的public属性（包括父类）
* getDeclaredField(String name)
   * 获取Class对象对应的类的指定参数的属性（不包括父类）（包括private）
   * 如果是private必须设置可访问 setAccessible(true);
* getMethods()
   * 获取Class对象对应的类的所有public方法（包括父类）	
* getDeclaredMethods()
   * 获取Class对象对应的类的所有方法（不包括父类）
* getMethod(String name, Class<?>... parameterTypes)
   * 获取Class对象对应的类的指定参数的public方法（包括父类） 
* getDeclaredMethod(String name, Class<?>... parameterTypes)
   * 获取Class对象对应的类的指定参数的方法（不包括父类）（包括private）
   * 如果是private必须设置可访问 setAccessible(true); 
::: details 代码实例解析
``` java
package com.escco.study;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.math.BigDecimal;

public class ReflectTest {

    public static void main(String[] args) throws Exception {
        Class computerClass = Class.forName("com.escco.study.Computer");
        // ------ 获取类的名称 ------
        // 获取类的名称 - 普通类
        // 运行结果：com.escco.study.Computer
        System.out.println(computerClass.getName());
        // 运行结果：Computer
        System.out.println(computerClass.getSimpleName());
        // 运行结果：com.escco.study.Computer
        System.out.println(computerClass.getCanonicalName());
        // 获取类的名称 - 内部类
        // 运行结果：com.escco.study.Computer$ComputerInner
        System.out.println(Computer.ComputerInner.class.getName());
        // 运行结果：ComputerInner
        System.out.println(Computer.ComputerInner.class.getSimpleName());
        // 运行结果：com.escco.study.Computer.ComputerInner
        System.out.println(Computer.ComputerInner.class.getCanonicalName());
        // 获取类的名称 - 数组
        // 运行结果：[Ljava.lang.String;
        System.out.println(args.getClass().getName());
        // 运行结果：String[]
        System.out.println(args.getClass().getSimpleName());
        // 运行结果：java.lang.String[]
        System.out.println(args.getClass().getCanonicalName());
        // ------ 接口相关 ------
        // 判断是否为接口
        // 运行结果：false
        System.out.println(computerClass.isInterface());
        // 获取类实现的接口的Class数组
        // 运行结果：
        // interface com.escco.study.DeviceAction
        // interface com.escco.study.DeviceAlert
        for (Class iI : computerClass.getInterfaces()) {
            System.out.println(iI);
        }
        // ------ 父类相关 ------
        // 运行结果：class com.escco.study.Device
        System.out.println(computerClass.getSuperclass());
        // ------ 使用无参构造方法创建对象 ------
        // 运行结果：I am a Computer
        Computer computer = (Computer) computerClass.newInstance();
        computer.sayDescription();
        // ------ 构造方法相关 ------
        // 获取类中的所有public构造方法（不包括父类）
        // 运行结果：
        // com.escco.study.Computer
        // com.escco.study.Computer
        for (Constructor c : computerClass.getConstructors()) {
            System.out.println(c.getName());
        }
        // 获取类中的所有构造方法（不包括父类）
        // 运行结果：
        // com.escco.study.Computer
        // com.escco.study.Computer
        // com.escco.study.Computer
        for (Constructor c : computerClass.getDeclaredConstructors()) {
            System.out.println(c.getName());
        }
        // 获取类中的指定参数的public构造方法（不包括父类）
        // 运行结果：Computer [brandName=Lenovo, price=6999]
        Constructor cs1 = computerClass.getConstructor(String.class, BigDecimal.class);
        Computer cs1Computer = (Computer) cs1.newInstance("Lenovo", BigDecimal.valueOf(6999));
        System.out.println(cs1Computer.toString());
        // 获取类中的指定参数的构造方法（不包括父类）
        // 运行结果：Computer [brandName=Dell, price=null]
        Constructor cs2 = computerClass.getDeclaredConstructor(String.class);
        // 由于是private必须设置可访问
        cs2.setAccessible(true);
        Computer cs2Computer = (Computer) cs2.newInstance("Dell");
        System.out.println(cs2Computer.toString());
        // ------ 属性相关 ------
        // 获取类中的所有public属性（包括父类）
        // 运行结果：
        // description
        // deviceType
        for (Field f : computerClass.getFields()) {
            System.out.println(f.getName());
        }
        // 获取类中的所有属性（不包括父类）
        // 运行结果：
        // brandName
        // price
        // description
        for (Field f : computerClass.getDeclaredFields()) {
            System.out.println(f.getName());
        }
        // 获取类中指定参数的public属性（包括父类）
        // 运行结果：Set deviceType to Computer
        Field fd1 = computerClass.getField("deviceType");
        fd1.set(cs1Computer, "Set deviceType to Computer");
        System.out.println(cs1Computer.deviceType);
        // 获取类中指定参数的属性（不包括父类）
        // 运行结果：9999
        Field fd2 = computerClass.getDeclaredField("price");
        fd2.setAccessible(true);
        fd2.set(cs1Computer, BigDecimal.valueOf(9999));
        System.out.println(cs1Computer.getPrice());
        // ------ 方法相关 ------
        // 获取类中的所有public方法（包括父类）
        // 运行结果：
        // error
        // toString
        // open
        // warning
        // sayDescription
        // getBrandName
        // setBrandName
        // getPrice
        // setPrice
        // shutDown
        // info
        // wait
        // wait
        // wait
        // equals
        // hashCode
        // getClass
        // notify
        // notifyAll
        for (Method m : computerClass.getMethods()) {
            System.out.println(m.getName());
        }
        // 获取类中的所有方法（不包括父类）
        // 运行结果：
        // error
        // toString
        // open
        // warning
        // sayDescription
        // getBrandName
        // setBrandName
        // getPrice
        // setPrice
        // heart
        // shutDown
        // info
        for (Method m : computerClass.getDeclaredMethods()) {
            System.out.println(m.getName());
        }
        // 获取类中的指定参数的public方法（包括父类）
        // 运行结果：heart2 heart2 heart2 heart2 heart2
        Method md1 = computerClass.getMethod("heart2", String.class);
        md1.invoke(cs1Computer, "heart2 heart2 heart2 heart2 heart2");
        // 获取类中的指定参数的方法（不包括父类）
        // 运行结果：Heart Computer
        Method md2 = computerClass.getDeclaredMethod("heart");
        md2.setAccessible(true);
        md2.invoke(cs1Computer);
    }

}

class Computer extends Device implements DeviceAction, DeviceAlert {
    private String brandName;

    private BigDecimal price;

    public String description;

    public Computer() {

    }

    private Computer(String brandName) {
        this.brandName = brandName;
    }

    public Computer(String brandName, BigDecimal price) {
        this.brandName = brandName;
        this.price = price;
    }

    public String getBrandName() {
        return brandName;
    }

    public void setBrandName(String brandName) {
        this.brandName = brandName;
    }

    public BigDecimal getPrice() {
        return price;
    }

    public void setPrice(BigDecimal price) {
        this.price = price;
    }

    private void heart() {
        System.out.println("Heart Computer");
    }

    @Override
    public void sayDescription() {
        System.out.println("I am a Computer");
    }

    @Override
    public String toString() {
        return "Computer [brandName=" + brandName + ", price=" + price + "]";
    }

    @Override
    public void open() {

    }

    @Override
    public void shutDown() {

    }

    @Override
    public void info() {

    }

    @Override
    public void warning() {

    }

    @Override
    public void error() {

    }

    static class ComputerInner {

    }
}

abstract class Device {
    public String deviceType;

    public Device() {

    }

    public abstract void sayDescription();

    private void heartDevice() {
        System.out.println("Heart Device");
    }

    @Override
    public String toString() {
        return "Device [deviceType=" + deviceType + "]";
    }
}

interface DeviceAction {
    public void open();
    public void shutDown();
}

interface DeviceAlert {
    public void info();
    public void warning();
    public void error();
}
```
:::
### Constructor  
Constructor 类存在于反射包 java.lang.reflect 中，是 Class 对象所表示的类的构造方法。
#### Constructor API
* newInstance()
   * 调用无参构造器，创建此 Class 对象所表示的类的一个新实例。
* newInstance(Object ... initargs)
   * 调用有参构造器，创建此 Class 对象所表示的类的一个新实例。 	
* getDeclaringClass()
   * 取得当前构造方法所属的Class对象
* getName()
   * 以字符串形式返回此构造方法的名称。 	
* toGenericString()
   * 以字符串形式返回此构造方法的详细信息，其中包括修饰符、名称、类型参数等。 	
* getGenericParameterTypes()
   * 取得当前构造方法的Type[]类型参数列表 	
* getParameterTypes()
   * 取得当前构造方法的Class[]类型参数列表  
::: details 代码实例解析
``` java
package com.escco.study;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Type;
import java.math.BigDecimal;

public class ReflectTest {

    public static void main(String[] args) throws Exception {
        Class computerClass = Class.forName("com.escco.study.Computer");
        // ------ 使用Class类提供的无参构造方法创建对象 ------
        // 运行结果：I am a Computer
        Computer computer = (Computer) computerClass.newInstance();
        computer.sayDescription();
        // ------ 使用Constructor类提供的无参构造方法创建对象 ------
        // 运行结果：Computer [brandName=null, price=null]
        Constructor cs0 = computerClass.getConstructor();
        Computer cs0Computer = (Computer) cs0.newInstance();
        System.out.println(cs0Computer.toString());
        // ------ 使用带String,BigDecimal参数的public构造函数创建对象 ------
        // 运行结果：Computer [brandName=Lenovo, price=6999]
        Constructor cs1 = computerClass.getConstructor(String.class, BigDecimal.class);
        Computer cs1Computer = (Computer) cs1.newInstance("Lenovo", BigDecimal.valueOf(6999));
        System.out.println(cs1Computer.toString());
        // ------ 使用带String参数的private构造函数创建对象 ------
        // 运行结果：Computer [brandName=Dell, price=null]
        Constructor cs2 = computerClass.getDeclaredConstructor(String.class);
        cs2.setAccessible(true);
        Computer cs2Computer = (Computer) cs2.newInstance("Dell");
        System.out.println(cs2Computer.toString());
        // ------ 获取当前构造方法所属的Class对象 ------
        // 运行结果：构造方法的类：com.escco.study.Computer
        Class cs0Class = cs0.getDeclaringClass();
        System.out.println("构造方法的类：" + cs0Class.getName());
        // ------ 获取所有构造方法，包含private ------
        // 运行结果：
        // 构造方法的类：com.escco.study.Computer
        // ----------------------
        // 构造名称：com.escco.study.Computer
        // 构造详细信息：public com.escco.study.Computer()
        // ----------------------
        // 构造名称：com.escco.study.Computer
        // 构造详细信息：public com.escco.study.Computer(java.lang.String,java.math.BigDecimal)
        // Type类型参数：class java.lang.String
        // Type类型参数：class java.math.BigDecimal
        // Class类型参数：java.lang.String
        // Class类型参数：java.math.BigDecimal
        // ----------------------
        // 构造名称：com.escco.study.Computer
        // 构造详细信息：private com.escco.study.Computer(java.lang.String)
        // Type类型参数：class java.lang.String
        // Class类型参数：java.lang.String
        Constructor consAttr[] = computerClass.getDeclaredConstructors();
        for (Constructor constructor : consAttr) {
            System.out.println("----------------------");
            // ------ 获取当前构造方法的名称 ------
            System.out.println("构造名称：" + constructor.getName());
            // ------ 获取当前构造方法的详细信息 ------
            System.out.println("构造详细信息：" + constructor.toGenericString());
            // ------ 获取当前构造方法的Type[]类型参数列表 ------
            Type[] tpeAttr = constructor.getGenericParameterTypes();
            for (Type tpe : tpeAttr) {
                System.out.println("Type类型参数：" + tpe);
            }
            // ------ 获取当前构造方法的Class[]类型参数列表 ------
            Class[] clsAttr = constructor.getParameterTypes();
            for (Class cls : clsAttr) {
                System.out.println("Class类型参数：" + cls.getName());
            }
        }
    }

}

class Computer extends Device implements DeviceAction, DeviceAlert {
    private String brandName;

    private BigDecimal price;

    public String description;

    public Computer() {

    }

    private Computer(String brandName) {
        this.brandName = brandName;
    }

    public Computer(String brandName, BigDecimal price) {
        this.brandName = brandName;
        this.price = price;
    }

    public String getBrandName() {
        return brandName;
    }

    public void setBrandName(String brandName) {
        this.brandName = brandName;
    }

    public BigDecimal getPrice() {
        return price;
    }

    public void setPrice(BigDecimal price) {
        this.price = price;
    }

    private void heart() {
        System.out.println("Heart Computer");
    }

    public void heart2(String message) {
        System.out.println(message);
    }

    @Override
    public void sayDescription() {
        System.out.println("I am a Computer");
    }

    @Override
    public String toString() {
        return "Computer [brandName=" + brandName + ", price=" + price + "]";
    }

    @Override
    public void open() {

    }

    @Override
    public void shutDown() {

    }

    @Override
    public void info() {

    }

    @Override
    public void warning() {

    }

    @Override
    public void error() {

    }

    static class ComputerInner {

    }
}

abstract class Device {
    public String deviceType;

    public Device() {

    }

    public abstract void sayDescription();

    private void heartDevice() {
        System.out.println("Heart Device");
    }

    @Override
    public String toString() {
        return "Device [deviceType=" + deviceType + "]";
    }
}

interface DeviceAction {
    public void open();
    public void shutDown();
}

interface DeviceAlert {
    public void info();
    public void warning();
    public void error();
}
```
:::
### Field  
Field 类提供有关类或接口的单个字段的信息，以及对它的动态访问权限。<br>
可能是一个类（静态）字段或实例字段。<br>
#### Field API
* setAccessible(boolean flag)
   * 设置私有属性的可访问性 
* set(Object obj, Object value)
   * 设置类的对象的属性值 
* get(Object obj)
   * 取得类的对象的属性值 
* getName()
   * 以字符串形式返回此属性的名称。 
* getType()
   * 以字符串形式返回此属性的声明类型。 
* isEnumConstant()
   * 判断此属性是否为枚举类型 
* toGenericString()
   * 以字符串形式返回此属性的详细信息，其中包括修饰符、名称、类型等。 
* getDeclaringClass()
   * 取得当前属性所属的Class对象 
::: details 代码实例解析
``` java
package com.escco.study;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Type;
import java.math.BigDecimal;

public class ReflectTest {

    public static void main(String[] args) throws Exception {
        Class computerClass = Class.forName("com.escco.study.Computer");
        // ------ 使用Class类提供的无参构造方法创建对象 ------
        Computer computer = (Computer) computerClass.newInstance();
        // ------ 通过Field的set方法设置类的对象的属性值 ------
        // 运行结果：9999
        Field fd1 = computerClass.getDeclaredField("price");
        fd1.setAccessible(true);
        fd1.set(computer, BigDecimal.valueOf(9999));
        System.out.println(computer.getPrice());
        // ------ 通过Field的get方法取得类的对象的属性值 ------
        // 运行结果：9999
        System.out.println(fd1.get(computer));
        // ------ 获取当前属性所属的Class对象 ------
        // 运行结果：属性的类：com.escco.study.Computer
        Class cs0Class = fd1.getDeclaringClass();
        System.out.println("属性的类：" + cs0Class.getName());
        // ------ 获取类中的所有属性（不包括父类） ------
        // ----------------------
        // 属性名称：brandName
        // 声明类型：class java.lang.String
        // 是否为枚举类型：false
        // 属性详细信息：private java.lang.String com.escco.study.Computer.brandName
        //----------------------
        // 属性名称：price
        // 声明类型：class java.math.BigDecimal
        // 是否为枚举类型：false
        // 属性详细信息：private java.math.BigDecimal com.escco.study.Computer.price
        //----------------------
        // 属性名称：description
        // 声明类型：class java.lang.String
        // 是否为枚举类型：false
        // 属性详细信息：public java.lang.String com.escco.study.Computer.description
        for (Field field : computerClass.getDeclaredFields()) {
            System.out.println("----------------------");
            System.out.println("属性名称：" + field.getName());
            System.out.println("声明类型：" + field.getType());
            System.out.println("是否为枚举类型：" + field.isEnumConstant());
            System.out.println("属性详细信息：" + field.toGenericString());
        }
    }

}

class Computer extends Device implements DeviceAction, DeviceAlert {
    private String brandName;

    private BigDecimal price;

    public String description;

    public Computer() {

    }

    private Computer(String brandName) {
        this.brandName = brandName;
    }

    public Computer(String brandName, BigDecimal price) {
        this.brandName = brandName;
        this.price = price;
    }

    public String getBrandName() {
        return brandName;
    }

    public void setBrandName(String brandName) {
        this.brandName = brandName;
    }

    public BigDecimal getPrice() {
        return price;
    }

    public void setPrice(BigDecimal price) {
        this.price = price;
    }

    private void heart() {
        System.out.println("Heart Computer");
    }

    public void heart2(String message) {
        System.out.println(message);
    }

    @Override
    public void sayDescription() {
        System.out.println("I am a Computer");
    }

    @Override
    public String toString() {
        return "Computer [brandName=" + brandName + ", price=" + price + "]";
    }

    @Override
    public void open() {

    }

    @Override
    public void shutDown() {

    }

    @Override
    public void info() {

    }

    @Override
    public void warning() {

    }

    @Override
    public void error() {

    }

    static class ComputerInner {

    }
}

abstract class Device {
    public String deviceType;

    public Device() {

    }

    public abstract void sayDescription();

    private void heartDevice() {
        System.out.println("Heart Device");
    }

    @Override
    public String toString() {
        return "Device [deviceType=" + deviceType + "]";
    }
}

interface DeviceAction {
    public void open();
    public void shutDown();
}

interface DeviceAlert {
    public void info();
    public void warning();
    public void error();
}
```
:::
### Method  
Method 类提供关于类或接口上单独某个方法（以及如何访问该方法）的信息<br>
可能是类方法或实例方法（包括抽象方法）。
#### Method API
* setAccessible(boolean flag)
   * 设置私有方法的可访问性 
* getDeclaringClass()
   * 取得当前方法所属的Class对象 
* invoke(Object obj)
   * 调用Class对象所属类的无参数方法 
* invoke(Object obj, Object... args)
   * 调用Class对象所属类的有参数方法  
* getName()
   * 以字符串形式返回此方法的名称
* toGenericString()
   * 以字符串形式返回此方法的详细信息，其中包括修饰符、名称、返回值、参数类型等。 
* isVarArgs()
   * 判断此方法是否包含可变参数 
* getReturnType()
   * 以Type形式返回此方法的返回值类型
* getGenericReturnType()
   * 以Class形式返回此方法的返回值类型 
* getGenericParameterTypes()
   * 取得当前方法的Type[]类型参数列表
* getParameterTypes()
   * 取得当前方法的Class[]类型参数列表 
::: details 代码实例解析
``` java
package com.escco.study;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Type;
import java.math.BigDecimal;

public class ReflectTest {

    public static void main(String[] args) throws Exception {
        Class computerClass = Class.forName("com.escco.study.Computer");
        // ------ 使用Class类提供的无参构造方法创建对象 ------
        Computer computer = (Computer) computerClass.newInstance();
        // ------ 调用类的对象的无参数方法 ------
        // 运行结果：Heart Computer
        Method md1 = computerClass.getDeclaredMethod("heart");
        md1.setAccessible(true);
        md1.invoke(computer);
        // ------ 调用类的对象的有参数方法 ------
        // 运行结果：heart2 heart2 heart2 heart2 heart2
        Method md2 = computerClass.getMethod("heart2", String.class);
        md2.invoke(computer, "heart2 heart2 heart2 heart2 heart2");
        // ------ 获取当前方法所属的Class对象 ------
        // 方法的类：com.escco.study.Computer
        Class cs0Class = md1.getDeclaringClass();
        System.out.println("方法的类：" + cs0Class.getName());
        // ------ 获取类中的所有方法（不包括父类） ------
        for (Method method : computerClass.getDeclaredMethods()) {
            System.out.println("----------------------");
            System.out.println("方法名称：" + method.getName());
            System.out.println("方法详细信息：" + method.toGenericString());
            System.out.println("是否包含可变参数：" + method.isVarArgs());
            System.out.println("方法的Type返回值类型：" + method.getReturnType());
            System.out.println("方法的Class返回值类型：" + method.getGenericReturnType());
            // ------ 获取当前方法的Type[]类型参数列表 ------
            Type[] tpeAttr = method.getGenericParameterTypes();
            for (Type tpe : tpeAttr) {
                System.out.println("Type类型参数：" + tpe);
            }
            // ------ 获取当前方法的Class[]类型参数列表 ------
            Class[] clsAttr = method.getParameterTypes();
            for (Class cls : clsAttr) {
                System.out.println("Class类型参数：" + cls.getName());
            }
        }
    }

}

class Computer extends Device implements DeviceAction, DeviceAlert {
    private String brandName;

    private BigDecimal price;

    public String description;

    public Computer() {

    }

    private Computer(String brandName) {
        this.brandName = brandName;
    }

    public Computer(String brandName, BigDecimal price) {
        this.brandName = brandName;
        this.price = price;
    }

    public String getBrandName() {
        return brandName;
    }

    public void setBrandName(String brandName) {
        this.brandName = brandName;
    }

    public BigDecimal getPrice() {
        return price;
    }

    public void setPrice(BigDecimal price) {
        this.price = price;
    }

    private void heart() {
        System.out.println("Heart Computer");
    }

    public void heart2(String message) {
        System.out.println(message);
    }

    @Override
    public void sayDescription() {
        System.out.println("I am a Computer");
    }

    @Override
    public String toString() {
        return "Computer [brandName=" + brandName + ", price=" + price + "]";
    }

    @Override
    public void open() {

    }

    @Override
    public void shutDown() {

    }

    @Override
    public void info() {

    }

    @Override
    public void warning() {

    }

    @Override
    public void error() {

    }

    static class ComputerInner {

    }
}

abstract class Device {
    public String deviceType;

    public Device() {

    }

    public abstract void sayDescription();

    private void heartDevice() {
        System.out.println("Heart Device");
    }

    @Override
    public String toString() {
        return "Device [deviceType=" + deviceType + "]";
    }
}

interface DeviceAction {
    public void open();
    public void shutDown();
}

interface DeviceAlert {
    public void info();
    public void warning();
    public void error();
}
```
:::
### AnnotatedElement
AnnotatedElement 接口是所有程序元素（Class、Method和Constructor）的父接口，<br>
所以程序通过反射获取了某个类的AnnotatedElement对象之后，程序就可以调用该对象的方法来访问Annotation信息。<br>
::: danger
只有注解被定义为RUNTIME后，该注解才能是运行时可见，当class文件被装载时被保存在class文件中的Annotation才会被虚拟机读取。
:::
#### AnnotatedElement API
* boolean isAnnotationPresent(Class\<?extends Annotation\> annotationClass)
   * 判断该程序元素上是否包含指定类型的注解。注意：此方法会忽略注解对应的注解容器。 	
* \<T extends Annotation\> T getAnnotation(Class\<T\> annotationClass)
   * 返回该程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null。
* Annotation[] getAnnotations()
   * 返回该程序元素上存在的所有注解，若没有注解，返回长度为0的数组。
* \<T extends Annotation\> T[] getAnnotationsByType(Class\<T\> annotationClass)
   * 返回该程序元素上存在的、指定类型的注解数组。没有注解对应类型的注解时，返回长度为0的数组。
   * 该方法的调用者可以随意修改返回的数组，而不会对其他调用者返回的数组产生任何影响。
   * getAnnotationsByType方法与 getAnnotation的区别在于，getAnnotationsByType会检测注解对应的重复注解容器。
   * 若程序元素为类，当前类上找不到注解，且该注解为可继承的，则会去父类上检测对应的注解。
* \<T extends Annotation\> T getDeclaredAnnotation(Class\<T\> annotationClass)
   * 返回直接存在于此元素上的所有注解。
   * 与此接口中的其他方法不同，该方法将忽略继承的注释。
   * 如果没有注释直接存在于此元素上，则返回null
* \<T extends Annotation\> T[] getDeclaredAnnotationsByType(Class\<T\> annotationClass)
   * 返回直接存在于此元素上的所有注解。
   * 与此接口中的其他方法不同，该方法将忽略继承的注释
* Annotation[] getDeclaredAnnotations()
   * 返回直接存在于此元素上的所有注解及注解对应的重复注解容器。
   * 与此接口中的其他方法不同，该方法将忽略继承的注解。
   * 如果没有注释直接存在于此元素上，则返回长度为零的一个数组。
   * 该方法的调用者可以随意修改返回的数组，而不会对其他调用者返回的数组产生任何影响。 
::: details 代码实例解析
ReflectTest.java <br>
``` java
package com.escco.study;

import javax.xml.ws.WebFault;
import java.lang.annotation.Annotation;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;

public class ReflectTest {

    public static void main(String[] args) throws Exception {
        // -------- 获取类的标注 --------
        Class clazz = Class.forName("com.escco.study.Sample");
        // 获得所有标注信息
        Annotation[] classAnns = clazz.getAnnotations();
        for (Annotation annotation : classAnns) {
            // 运行结果：
            // interface javax.xml.ws.WebFault
            // interface javax.jws.WebService
            System.out.println(annotation.annotationType());
        }
        // 获得单个标注信息
        // 运行结果：WebFault标注的name：xxx
        WebFault webFault = (WebFault) clazz.getAnnotation(WebFault.class);
        if (webFault != null) {
            System.out.println("WebFault标注的name：" + webFault.name());
        } else {
            System.out.println("没有WebFault标注");
        }
        // -------- 获取属性的标注 --------
        Field field = clazz.getDeclaredField("name");
        // 获得所有标注信息
        Annotation[] fieldAnns = field.getAnnotations();
        for (Annotation annotation : fieldAnns) {
            // 运行结果：@java.lang.Deprecated()
            System.out.println(annotation);
        }
        // -------- 获取构造方法的标注 --------
        Constructor constructor = clazz.getDeclaredConstructor();
        // 获得所有标注信息
        Annotation[] constructorAnns = constructor.getAnnotations();
        for (Annotation annotation : constructorAnns) {
            // 运行结果：@org.springframework.beans.factory.annotation.Autowired(required=true)
            System.out.println(annotation);
        }
        // -------- 获取方法的标注 --------
        Method method = clazz.getDeclaredMethod("sayHello");
        // 获得所有标注信息
        Annotation[] methodAnns = method.getAnnotations();
        for (Annotation annotation : methodAnns) {
            // 运行结果：@jdk.nashorn.internal.runtime.logging.Logger(name=)
            System.out.println(annotation);
        }
    }

}
```
Sample.java <br>
``` java
package com.escco.study;

import jdk.nashorn.internal.runtime.logging.Logger;
import org.springframework.beans.factory.annotation.Autowired;

import javax.jws.WebService;
import javax.xml.ws.WebFault;

@WebFault(name="xxx")
@WebService(name="test")
public class Sample {
    @Deprecated
    private String name;
    @Autowired
    Sample() {

    }
    @Logger
    Sample(String name) {

    }
    public static void main(String[] args) {
        System.out.println("Sample Class's main run");
    }
    @Logger
    private void sayHello() {
        System.out.println("Sample Class's sayHello run");
    }
}
```
::: 
### Type 
为了使用泛型又不真正引入泛型，Java采用泛型擦除机制来引入泛型。<br>
Java中的泛型仅仅是给编译器javac使用的，确保数据的安全性和免去强制类型转换的麻烦。<br>
但是，一旦编译完成，所有的和泛型有关的类型全部擦除。<br>
因此，与泛型有关的参数化类型、类型变量类型、限定符类型、泛型数组类型编译后全部被打回原形，<br>
在字节码文件中全部都是泛型被擦除后的原始类型，并不存在和自身类型对应的字节码文件。<br>
所以和泛型相关的新扩充进来的类型不能被统一到Class类中。<br>
为了通过反射操作这些类型以迎合实际开发的需要，<br>
Java就新增了ParameterizedType, TypeVariable, GenericArrayType, WildcardType几种类型来代表不能被归到Class类中，但是又和原始类型齐名的类型。<br>
为了程序的扩展性，最终引入了Type接口作为Class和ParameterizedType, TypeVariable, GenericArrayType, WildcardType这几种类型的总的父接口。<br>
这样可以用Type类型的参数来接受以上五种子类的实参或者返回值类型就是Type类型的参数。<br>
* Type是个空接口，没有定义任何方法
   * Type的出现仅仅起到了通过多态来达到程序扩展性提高的作用，没有其他的作用。
<br><br>
* Type是Java语言中所有类型的公共父接口，包括
   * Class 类，用于原始类型（raw types）
   * ParameterizedType 接口，参数化类型（parameterized types） 
   * GenericArrayType 接口，数组类型（array types） 
   * TypeVariable 接口，类型变量（type variables）
   * WildcardType 接口，通配符类型（wildcard type）
<br><br><br>
![images](/images/java/type_class.jpg)
<br><br><br>
### ParameterizedType
参数化类型，即我们通常所说的泛型类型，包括如下形式：
``` java
Map<String, Person> map;
Set<String> set1;
Class<?> clz;
Holder<String> holder;
List<String> list;
static class Holder<V> {}
```
#### ParameterizedType API
* Type[] getActualTypeArguments()
   * 返回该参数化类型中包含参数的Type类型数组。 
   * 如 Map<String,Person> map 这个 ParameterizedType 返回的是 String 类，Person 类的全限定类名的 Type 数组 	
* Type getRawType()
   * 返回该参数化类型的Type类型。 
   * 如 Map<String,Person> map 这个 ParameterizedType 返回的是 Map 类的全限定类名的 Type 
* Type getOwnerType()
   * 返回该参数化类型的所属类型的Type类型。
   * 比如 Map<String,Person> map 的 参数化类型没有所属类型，所以返回值为 null
   * 比如 Map.Entry<String, String> entry 的 参数化类型的所属类型 为 Map，所以返回值为 Map
::: details 代码实例解析
``` java
package com.escco.study;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class ReflectTestOther {

    public static void main(String[] args) throws Exception {

        Field[] fields = ParameterizedTypeBean.class.getDeclaredFields();
        for (int i = 0; i < fields.length; i++) {
            Field f = fields[i];
            // ------ 判断属性类型是否属于ParameterizedType
            // 运行结果：
            // map 是否属于 ParameterizedType ：true
            // 泛型类型：class java.lang.String
            // 泛型类型：class java.lang.Integer
            // 所属类型：interface java.util.Map
            // 所在类的所属类型：null
            // clz 是否属于 ParameterizedType ：true
            // 泛型类型：?
            // 所属类型：class java.lang.Class
            // 所在类的所属类型：null
            // list 是否属于 ParameterizedType ：true
            // 泛型类型：class java.lang.String
            // 所属类型：interface java.util.List
            // 所在类的所属类型：null
            // entry 是否属于 ParameterizedType ：true
            // 泛型类型：class java.lang.String
            // 泛型类型：class java.lang.String
            // 所属类型：interface java.util.Map$Entry
            // 所在类的所属类型：interface java.util.Map
            // str 是否属于 ParameterizedType ：false
            // aList 是否属于 ParameterizedType ：false
            boolean parameterizedTypeFlag = f.getGenericType() instanceof ParameterizedType;
            System.out.println(f.getName() + " 是否属于 ParameterizedType ：" + parameterizedTypeFlag);
            if (parameterizedTypeFlag) {
                ParameterizedType parameterizedType = (ParameterizedType) f.getGenericType();
                // ------ 打印 该参数化类型中包含参数的Type类型 ------
                for (Type type : parameterizedType.getActualTypeArguments()) {
                    System.out.println("泛型类型：" + type);
                }
                // ------ 打印 该参数化类型的Type类型 ------
                System.out.println("所属类型：" + parameterizedType.getRawType());
                // ------ 打印 该参数化类型的所在类的Type类型 ------
                System.out.println("所在类的所属类型：" + parameterizedType.getOwnerType());
            }
        }

    }

}

class ParameterizedTypeBean {
    // 下面的 field 的 Type 属于 ParameterizedType
    Map<String, Integer> map;
    Class<?> clz;
    List<String> list;
    // Map<String,Integer> map 这个 ParameterizedType 的 getOwnerType() 为 null，
    // 而 Map.Entry<String, String> entry 的 getOwnerType() 为 Map 所属于的 Type。
    Map.Entry<String, String> entry;
    // 下面的 field 的 Type 不属于ParameterizedType
    String str;
    List aList;
    static class Holder<V> {

    }
}
```
:::
### GenericArrayType
泛型数组类型，用来描述ParameterizedType、TypeVariable类型的数组，包括如下形式：
``` java
// 属于 GenericArrayType
List<String>[] pTypeArray;
// 属于 GenericArrayType
T[] vTypeArray;
// 不属于 GenericArrayType
List<String> list;
// 不属于 GenericArrayType
String[] strings;
// 不属于 GenericArrayType
Person[] ints;
```
#### GenericArrayType API
* Type getGenericComponentType()
   * 返回泛型数组类型中元素的Type类型
   * 例如：T[] 返回的是 T
::: details 代码实例解析
``` java
package com.escco.study;

import java.lang.reflect.*;
import java.util.List;

public class ReflectTestOther {

    public static void main(String[] args) throws Exception {

        Class clazz = GenericArrayTypeBean.class;
        Method method = clazz.getDeclaredMethod("test", List[].class, Object[].class, List.class, String[].class);
        // ------ 输出获取的方法信息 ------
        // 输出结果：public void com.escco.study.GenericArrayTypeBean.test(java.util.List[],java.lang.Object[],java.util.List,java.lang.String[])
        System.out.println(method);
        Type[] types = method.getGenericParameterTypes();
        // ------ 输出方法的参数信息 ------
        // java.util.List<java.lang.String>[] 是否属于 GenericArrayType ：true
        // 带泛型的参数类型：java.util.List<java.lang.String>
        // java.util.List<java.lang.String> 是否属于 ParameterizedType ：true
        // 泛型类型：class java.lang.String
        // T[] 是否属于 GenericArrayType ：true
        // 带泛型的参数类型：T
        // T 是否属于 ParameterizedType ：false
        // java.util.List<java.lang.String> 是否属于 GenericArrayType ：false
        // class [Ljava.lang.String; 是否属于 GenericArrayType ：false
        for (Type type : types) {
            // ------ 判断方法的参数类型是否属于GenericArrayType
            boolean genericArrayTypeFlag = type instanceof GenericArrayType;
            System.out.println(type + " 是否属于 GenericArrayType ：" + genericArrayTypeFlag);
            if (genericArrayTypeFlag) {
                GenericArrayType genericArrayType = (GenericArrayType) type;
                System.out.println("带泛型的参数类型：" + genericArrayType.getGenericComponentType());
                boolean parameterizedTypeFlag = genericArrayType.getGenericComponentType() instanceof ParameterizedType;
                System.out.println(genericArrayType.getGenericComponentType() + " 是否属于 ParameterizedType ：" + parameterizedTypeFlag);
                if (parameterizedTypeFlag) {
                    ParameterizedType parameterizedType = (ParameterizedType) genericArrayType.getGenericComponentType();
                    // ------ 打印 该参数化类型中包含参数的Type类型 ------
                    for (Type innerType : parameterizedType.getActualTypeArguments()) {
                        System.out.println("泛型类型：" + innerType);
                    }
                }
            }
        }
    }

}

class GenericArrayTypeBean<T> {

    public void test(List<String>[] pTypeArray,
                     T[] vTypeArray,
                     List<String> list,
                     String[] strings) {
    }

}
```
:::
### TypeVariable
类型变量，即泛型中的变量，就是我们常用的T、K、V这种泛型变量，可以表示任何类
``` java
T[] vTypeArray = null;
public class TypeVariableBean<K extends InputStream & Serializable, V>;
```
#### TypeVariable API
* Type[] getBounds()
   * 得到该类型变量的上边界的Type数组
   * 例如 public class TypeVariableBean<K extends InputStream & Serializable, V>
      * K 的上边界数组是 InputStream 和 Serializable。
      * V 没有指定的话，上边界是 Object 	
* D getGenericDeclaration()
   * 返回该类型变量的所在类的Type	
* String getName()
   * 返回该类型变量的变量名称 
::: details 代码实例解析
``` java
package com.escco.study;

import java.io.Closeable;
import java.io.InputStream;
import java.lang.reflect.Field;
import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;
import java.util.List;

public class ReflectTestOther {

    public static void main(String[] args) throws Exception {

        Class clazz = TypeVariableBean.class;
        Field[] fields = clazz.getDeclaredFields();
        // 输出结果：
        // key 是否属于 TypeVariable ：true
        // 变量名称：K
        // 上边界类型：class java.io.InputStream
        // 上边界类型：interface java.io.Closeable
        // 所在类：class com.escco.study.TypeVariableBean
        // value 是否属于 TypeVariable ：true
        // 变量名称：V
        // 上边界类型：class java.lang.Object
        // 所在类：class com.escco.study.TypeVariableBean
        // values 是否属于 TypeVariable ：false
        // str 是否属于 TypeVariable ：false
        // kList 是否属于 TypeVariable ：false
        for (int i = 0; i < fields.length; i++) {
            Field f = fields[i];
            // ------ 判断属性类型是否属于 TypeVariable
            boolean typeVariableFlag = f.getGenericType() instanceof TypeVariable;
            System.out.println(f.getName() + " 是否属于 TypeVariable ：" + typeVariableFlag);
            if (typeVariableFlag) {
                TypeVariable typeVariable = (TypeVariable) f.getGenericType();
                System.out.println("变量名称：" + typeVariable.getName());
                for (Type type : typeVariable.getBounds()) {
                    System.out.println("上边界类型：" + type);
                }
                System.out.println("所在类：" + typeVariable.getGenericDeclaration());
            }
        }
    }

}

class TypeVariableBean<K extends InputStream & Closeable, V> {
    // K 的上边界是 InputStream
    K key;
    // 没有指定的话 ，V 的 上边界 属于 Object
    V value;
    // 不属于 TypeTypeVariable
    V[] values;
    String str;
    List<K> kList;
}
```
:::
### WildcardType
* 通配符类型
   * extends 用来指定上边界，没有指定的话上边界默认是 Object
   * super 用来指定下边界，没有指定的话为 null
``` java
List<? extends Number>;
List<? super Number>;
```
#### WildcardType API
* Type[] getLowerBounds() 
   * 得到上边界 Type 的数组 	
* Type[] getUpperBounds() 
   * 得到下边界 Type 的数组	
::: details 代码实例解析
``` java
package com.escco.study;

import java.lang.reflect.*;
import java.util.List;

public class ReflectTestOther {

    public static void main(String[] args) throws Exception {

        Class clazz = WildcardTypeBean.class;
        Field[] fields = clazz.getDeclaredFields();
        // 输出结果：
        // a 是否属于 ParameterizedType ：true
        // a 是否属于 WildcardType ：true
        // 上边界：class java.lang.Number
        // b 是否属于 ParameterizedType ：true
        // b 是否属于 WildcardType ：true
        // 上边界：class java.lang.Object
        // 下边界：class java.lang.String
        // c 是否属于 ParameterizedType ：true
        // c 是否属于 WildcardType ：false
        // aClass 是否属于 ParameterizedType ：true
        // aClass 是否属于 WildcardType ：true
        // 上边界：class java.lang.Object
        for (int i = 0; i < fields.length; i++) {
            Field f = fields[i];
            // ------ 1. 判断属性类型是否属于 WildcardType
            boolean parameterizedTypeFlag = f.getGenericType() instanceof ParameterizedType;
            System.out.println(f.getName() + " 是否属于 ParameterizedType ：" + parameterizedTypeFlag);
            if (parameterizedTypeFlag) {
                ParameterizedType parameterizedType = (ParameterizedType) f.getGenericType();
                // ------ 打印 该参数化类型中包含参数的Type类型 ------
                for (Type type : parameterizedType.getActualTypeArguments()) {
                    // ------ 2. 判断参数类型是否属于 WildcardType
                    boolean wildcardTypeFlag = type instanceof WildcardType;
                    System.out.println(f.getName() + " 是否属于 WildcardType ：" + wildcardTypeFlag);
                    if (wildcardTypeFlag) {
                        WildcardType wildcardType = (WildcardType) type;
                        // ------ 3. 上边界
                        Type[] upTypes = wildcardType.getUpperBounds();
                        if (upTypes != null) {
                            for (Type upType : upTypes) {
                                System.out.println("上边界：" + upType);
                            }
                        }
                        // ------ 4. 下边界
                        Type[] loTypes = wildcardType.getLowerBounds();
                        if (loTypes != null) {
                            for (Type loType : loTypes) {
                                System.out.println("下边界：" + loType);
                            }
                        }
                    }
                }
            }
        }
    }

}

class WildcardTypeBean {
    // a没有下界
    private List<? extends Number> a;
    // 没有指定的话，上边界默认是 Object ,下边界是String
    private List<? super String> b;

    private List<String> c;

    private Class<?> aClass;
}
```
:::
## 反射的使用流程
1. 获取某类的 Class 对象
2. 根据需求，利用 Class 对象提供的方法，获取和操作对应的构造方法、方法和变量
3. 进行实例化该对象、操作方法和操作变量等具体操作
## 反射机制内部的执行的流程
* 反射类及反射方法的获取，都是通过从列表中搜寻查找匹配的方法，所以查找性能会随类的大小方法多少而变化； 
* 反射是线程安全的，放心使用；
<br><br>
* 反射机制的执行的流程图
<br><br>
![images](/images/java/java-basic-reflection-1.png)
<br><br>
## 反射的使用
### 通过反射调用main方法
::: details 代码实例解析
ReflectTestOther.java<br>
``` java
package com.escco.study;

import java.lang.reflect.Method;

public class ReflectTestOther {

    public static void main(String[] args) throws Exception {
        Class clazz = Class.forName("com.escco.study.Sample");
        Method methodMain = clazz.getMethod("main", String[].class);
        // 运行结果：Sample Class's main run
        methodMain.invoke(null, (Object)new String[]{});
    }

}
```
Sample.java<br>
``` java
package com.escco.study;

public class Sample {
    public static void main(String[] args) {
        System.out.println("Sample Class's main run");
    }
}
```
:::
### 通过反射运行配置文件中指定的方法
::: details 代码实例解析
ReflectTestOther.java<br>
``` java
package com.escco.study;

import java.io.File;
import java.io.FileInputStream;
import java.lang.reflect.Method;
import java.util.Properties;

public class ReflectTestOther {

    public static void main(String[] args) throws Exception {
        // 从config.txt中获取类名称和方法名称
        File configFile = new File("config.txt");
        Properties springConfig= new Properties();
        springConfig.load(new FileInputStream(configFile));
        String className = (String) springConfig.get("class");
        String methodName = (String) springConfig.get("method");
        Class clazz = Class.forName(className);
        Sample sample = (Sample) clazz.newInstance();
        Method methodMain = clazz.getDeclaredMethod(methodName);
        methodMain.setAccessible(true);
        // 运行结果：Sample Class's sayHello run
        methodMain.invoke(sample);
    }

}

```
Sample.java<br>
``` java
package com.escco.study;

public class Sample {
    Sample() {
    }
    public static void main(String[] args) {
        System.out.println("Sample Class's main run");
    }
    private void sayHello() {
        System.out.println("Sample Class's sayHello run");
    }
}

```
config.txt<br>
``` java
class=com.escco.study.Sample
method=sayHello
```
:::
### 通过反射越过泛型检查
::: details 代码实例解析
``` java
package com.escco.study;

import java.lang.reflect.Method;
import java.util.ArrayList;

public class ReflectTestOther {

    public static void main(String[] args) throws Exception {
        ArrayList<String> strlist = new ArrayList<>();
        strlist.add("this");
        strlist.add("is");
        // strlist.add(5); 编译不通过，提示类型错误
        /********** 越过泛型检查 **************/
        // 获取ArrayList的Class对象，反向的调用add()方法，添加数据
        Class listClass = strlist.getClass();
        // 获取add()方法
        Method method = listClass.getMethod("add", Object.class);
        // 调用add()方法
        method.invoke(strlist, 5);
        // 遍历集合
        for(Object obj : strlist){
            System.out.println(obj);
        }
    }

}

运行结果：
this
is
5
```
:::
### 通过反射获取父类的所有私有属性
* 如果在该类中找不到此方法，就向他的父类找，一直到Object类为止
``` java
for(;clazz != Object.class; clazz = clazz.getSuperclass()){
    try {
        Method method = clazz.getDeclaredMethod(methodName, parameterTypes);
        return method;
    } catch (Exception e) {}            
}
```
::: details 代码实例解析
``` java
package com.escco.study;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.math.BigDecimal;

public class ReflectTest {

    public static void main(String[] args) throws Exception {
        Class computerClass = Class.forName("com.escco.study.Computer");
        Class superClass = computerClass.getSuperclass();
        Constructor cs1 = superClass.getDeclaredConstructor(String.class);
        cs1.setAccessible(true);
        // ------ 获取父类的私有构造方法 ------
        // 运行结果：private com.escco.study.Device(java.lang.String)
        System.out.println(cs1.toGenericString());
        // ------ 获取父类的私有属性 ------
        // 运行结果：private java.lang.String com.escco.study.Device.deviceName
        Field fd1 = superClass.getDeclaredField("deviceName");
        fd1.setAccessible(true);
        System.out.println(fd1.toGenericString());
        // ------ 获取父类的私有方法 ------
        // 运行结果：private void com.escco.study.Device.heartDevice()
        Method md1 = superClass.getDeclaredMethod("heartDevice");
        md1.setAccessible(true);
        System.out.println(md1.toGenericString());
    }

}

class Computer extends Device {
    private String brandName;

    private BigDecimal price;

    public String description;

    public Computer() {

    }

    private Computer(String brandName) {
        this.brandName = brandName;
    }

    public Computer(String brandName, BigDecimal price) {
        this.brandName = brandName;
        this.price = price;
    }

    public String getBrandName() {
        return brandName;
    }

    public void setBrandName(String brandName) {
        this.brandName = brandName;
    }

    public BigDecimal getPrice() {
        return price;
    }

    public void setPrice(BigDecimal price) {
        this.price = price;
    }

    private void heart() {
        System.out.println("Heart Computer");
    }

    public void heart2(String message) {
        System.out.println(message);
    }

    @Override
    public void sayDescription() {
        System.out.println("I am a Computer");
    }

    @Override
    public String toString() {
        return "Computer [brandName=" + brandName + ", price=" + price + "]";
    }

    static class ComputerInner {

    }
}

abstract class Device {
    public String deviceType;

    private String deviceName;

    public Device() {
    }

    private Device(String deviceName) {
        this.deviceName = deviceName;
    }

    public String getDeviceName() {
        return deviceName;
    }

    public void setDeviceName(String deviceName) {
        this.deviceName = deviceName;
    }

    public abstract void sayDescription();

    private void heartDevice() {
        System.out.println("Heart Device");
    }

    @Override
    public String toString() {
        return "Device [deviceType=" + deviceType + "]";
    }
}
```
:::
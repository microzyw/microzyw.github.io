# Java 多线程集合体系
::: tip
本文主要对 Java多线程集合体系 的基本情况进行总结。@Frank Zhao
:::
## 本章目录
[[toc]]
## Java 多线程集合（JUC集合）
Java集合包大多是“非线程安全的”，虽然可以通过Collections工具类中的方法获取Java集合包对应的同步类，但是这些同步类的并发效率并不是很高。<br>
为了更好的支持高并发任务，并发大师Doug Lea在JUC(java.util.concurrent)包中添加了Java集合包中单线程类的对应的支持高并发的类。<br>
JUC包在添加”java集合包“对应的高并发类时，为了保持API接口的一致性，使用了”Java集合包“中的框架。<br>
## CopyOnWrite 容器
CopyOnWrite 容器 即 写时复制的容器。<br>
通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，<br>
复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。<br>
这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。<br>
所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。<br>
::: warning
* CopyOnWrite容器 适用于读多写少的应用场景。
   * 由于 读的时候使用了 ReentrantLock(重入锁) 所以多个线程同时写入的时候不会出现数据不一致的情况
:::
## Concurrent 容器
内部使用段（Segment）来表示这些的不同部分，每个段其实就是一个小的 HashTable，他们都有自己的锁。<br>
只要修改操作发生在不同的段上，就可以并发的进行。<br>
如果多个修改发生在同一个端上，那就只能排队等待。<br>
::: warning
把一个整体分成 16 段。也就是最高支持16个线程的并发操作。<br>
这也是在多线程场景时，减小锁的粒度，从而降低锁的竞争的一种解决方案。<br>
代码中大多共享变量使用 volatile 关键字声明，目的是第一时间获取修改的内容，性能非常好。<br>
:::
## Java 多线程集合类图
<br>
<img src="/images/java/22234145t3m9.png" width="100%" height="100%" />
<br><br>
<img src="/images/java/22234145t3m10.jpg" width="100%" height="100%" />
<br><br>

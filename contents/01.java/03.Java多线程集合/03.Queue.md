# Queue
::: tip
本文主要对 Queue 多线程 的基本情况进行总结。@Frank Zhao
:::
## 本章目录
[[toc]]
## ArrayBlockingQueue
* ArrayBlockingQueue 是数组实现的线程安全的有界的阻塞队列。
   * 线程安全是指，ArrayBlockingQueue 内部通过“互斥锁”保护竞争资源，实现了多线程对竞争资源的互斥访问。				
   * 有界，则是指 ArrayBlockingQueue 对应的数组是有界限的，需要在构造时指定容量，并可以选择公平性					
   * 阻塞队列，是指多线程访问竞争资源时，当竞争资源已被某线程获取时，其它要获取该资源的线程需要阻塞等待。		
* ArrayBlockingQueue 是按 FIFO（先进先出）原则对元素进行排序，元素都是从尾部插入到队列，从头部开始返回。			
``` java
public class ArrayBlockingQueue<E> extends AbstractQueue<E>
        implements BlockingQueue<E>, java.io.Serializable
```
* BlockingQueue - 表示 ArrayBlockingQueue 是 阻塞队列
* Serializable - 表示 ArrayBlockingQueue 支持序列化，能通过序列化去传输。
### ArrayBlockingQueue 代码解析
* ArrayBlockingQueue内部是通过Object[]数组保存数据的，也就是说ArrayBlockingQueue本质上是通过数组实现的。			
   * ArrayBlockingQueue的大小，即数组的容量是创建ArrayBlockingQueue时指定的。							
* ArrayBlockingQueue与ReentrantLock是组合关系，ArrayBlockingQueue中包含一个ReentrantLock对象(lock)。				
   * ReentrantLock是可重入的互斥锁，ArrayBlockingQueue就是根据该互斥锁实现“多线程对竞争资源的互斥访问”。		
   * 而且，ReentrantLock分为公平锁和非公平锁，关于具体使用公平锁还是非公平锁，在创建ArrayBlockingQueue时可以指定；	
   * 而且，ArrayBlockingQueue默认会使用非公平锁。							
* ArrayBlockingQueue与Condition是组合关系，ArrayBlockingQueue中包含两个Condition对象(notEmpty和notFull)。		
   * 而且，Condition又依赖于ArrayBlockingQueue而存在，通过Condition可以实现对ArrayBlockingQueue的更精确的访问	
      * 若某线程(线程A)要取数据时，数组正好为空，则该线程会执行notEmpty.await()进行等待；							
         * 当其它某个线程(线程B)向数组中插入了数据之后，会调用notEmpty.signal()唤醒“notEmpty上的等待线程”。		
         * 此时，线程A会被唤醒从而得以继续运行。					
      * 若某线程(线程H)要插入数据时，数组已满，则该线程会它执行notFull.await()进行等待；							
         * 当其它某个线程(线程I)取出数据之后，会调用notFull.signal()唤醒“notFull上的等待线程”。					
         * 此时，线程H就会被唤醒从而得以继续运行。	
``` java
/** The queued items */
final Object[] items;

/** Main lock guarding all access */
final ReentrantLock lock;

/** Condition for waiting takes */
private final Condition notEmpty;

/** Condition for waiting puts */
private final Condition notFull;
```
### ArrayBlockingQueue 函数列表
::: details 函数列表
``` java
// 创建一个带有给定的（固定）容量和默认访问策略的 ArrayBlockingQueue。								
ArrayBlockingQueue(int capacity)								
// 创建一个具有给定的（固定）容量和指定访问策略的 ArrayBlockingQueue。								
ArrayBlockingQueue(int capacity, boolean fair)								
// 创建一个具有给定的（固定）容量和指定访问策略的 ArrayBlockingQueue，它最初包含给定 collection 的元素，并以 collection 迭代器的遍历顺序添加元素。								
ArrayBlockingQueue(int capacity, boolean fair, Collection<? extends E> c)								
// 将指定的元素插入到此队列的尾部（如果立即可行且不会超过该队列的容量），在成功时返回 true，如果此队列已满，则抛出 IllegalStateException。								
boolean add(E e)								
// 自动移除此队列中的所有元素。								
void clear()								
// 如果此队列包含指定的元素，则返回 true。								
boolean contains(Object o)								
// 移除此队列中所有可用的元素，并将它们添加到给定 collection 中。								
int drainTo(Collection<? super E> c)								
// 最多从此队列中移除给定数量的可用元素，并将这些元素添加到给定 collection 中。								
int drainTo(Collection<? super E> c, int maxElements)								
// 返回在此队列中的元素上按适当顺序进行迭代的迭代器。								
Iterator<E> iterator()								
// 将指定的元素插入到此队列的尾部（如果立即可行且不会超过该队列的容量），在成功时返回 true，如果此队列已满，则返回 false。								
boolean offer(E e)								
// 将指定的元素插入此队列的尾部，如果该队列已满，则在到达指定的等待时间之前等待可用的空间。		
boolean offer(E e, long timeout, TimeUnit unit)								
// 获取但不移除此队列的头；如果此队列为空，则返回 null。								
E peek()								
// 获取并移除此队列的头，如果此队列为空，则返回 null。								
E poll()								
// 获取并移除此队列的头部，在指定的等待时间前等待可用的元素（如果有必要）。								
E poll(long timeout, TimeUnit unit)								
// 将指定的元素插入此队列的尾部，如果该队列已满，则等待可用的空间。								
void put(E e)								
// 返回在无阻塞的理想情况下（不存在内存或资源约束）此队列能接受的其他元素数量。								
int remainingCapacity()								
// 从此队列中移除指定元素的单个实例（如果存在）。								
boolean remove(Object o)								
// 返回此队列中元素的数量。								
int size()								
// 获取并移除此队列的头部，在元素变得可用之前一直等待（如果有必要）。								
E take()								
// 返回一个按适当顺序包含此队列中所有元素的数组。								
Object[] toArray()								
// 返回一个按适当顺序包含此队列中所有元素的数组；返回数组的运行时类型是指定数组的运行时类型。	
<T> T[] toArray(T[] a)								
// 返回此 collection 的字符串表示形式。								
String toString()								
```
:::
### ArrayBlockingQueue 示例
::: details 代码实例解析
``` java
package com.escco.test;

import java.util.*;
import java.util.concurrent.*;

/*
 *   ArrayBlockingQueue是“线程安全”的队列，而LinkedList是非线程安全的。
 *   下面是“多个线程同时操作并且遍历queue”的示例
 *   (01) 当queue是ArrayBlockingQueue对象时，程序能正常运行。
 *   (02) 当queue是LinkedList对象时，程序会产生ConcurrentModificationException异常。
 */
public class Test {

    // queue是LinkedList对象时，程序会出错。
    // private static Queue<String> queue = new LinkedList<String>();
    private static Queue<String> queue = new ArrayBlockingQueue<String>(20);

    public static void main(String[] args) {
        // 同时启动两个线程对queue进行操作！
        new MyThread("ta").start();
        new MyThread("tb").start();
    }

    private static void printAll() {
        String value;
        Iterator iter = queue.iterator();
        while(iter.hasNext()) {
            value = (String)iter.next();
            System.out.print(value+", ");
        }
        System.out.println();
    }

    private static class MyThread extends Thread {
        MyThread(String name) {
            super(name);
        }
        @Override
        public void run() {
            int i = 0;
            while (i++ < 6) {
                // “线程名” + "-" + "序号"
                String val = Thread.currentThread().getName()+i;
                queue.add(val);
                // 通过“Iterator”遍历queue。
                printAll();
            }
        }
    }

}

运行结果：
tb1, 
tb1, tb2, 
tb1, tb2, tb3, 
tb1, tb2, tb3, tb4, 
tb1, tb2, tb3, tb4, tb5, 
tb1, tb2, tb3, tb4, tb5, tb6, 
tb1, tb2, tb3, tb4, tb5, tb6, ta1, 
tb1, tb2, tb3, tb4, tb5, tb6, ta1, ta2, 
tb1, tb2, tb3, tb4, tb5, tb6, ta1, ta2, ta3, 
tb1, tb2, tb3, tb4, tb5, tb6, ta1, ta2, ta3, ta4, 
tb1, tb2, tb3, tb4, tb5, tb6, ta1, ta2, ta3, ta4, ta5, 
tb1, tb2, tb3, tb4, tb5, tb6, ta1, ta2, ta3, ta4, ta5, ta6, 

结果说明：
如果将源码中的queue改成LinkedList对象时，程序会产生ConcurrentModificationException异常。

```
:::
## LinkedBlockingQueue
``` java
public class LinkedBlockingQueue<E> extends AbstractQueue<E>
        implements BlockingQueue<E>, java.io.Serializable
```
### LinkedBlockingQueue 代码解析
``` java
```
### LinkedBlockingQueue 函数列表
::: details 函数列表
``` java
```
:::
### LinkedBlockingQueue 示例
::: details 代码实例解析
``` java
```
:::
## PriorityBlockingQueue
``` java
```
### xxx 代码解析
``` java
```
### xxx 函数列表
::: details 函数列表
``` java
```
:::
### xxx 示例
::: details 代码实例解析
``` java
```
:::
## DelayQueue
``` java
```
### xxx 代码解析
``` java
```
### xxx 函数列表
::: details 函数列表
``` java
```
:::
### xxx 示例
::: details 代码实例解析
``` java
```
:::
## ConcurrentLinkedQueue
``` java
```
### xxx 代码解析
``` java
```
### xxx 函数列表
::: details 函数列表
``` java
```
:::
### xxx 示例
::: details 代码实例解析
``` java
```
:::
## SynchronousQueue
``` java
```
### xxx 代码解析
``` java
```
### xxx 函数列表
::: details 函数列表
``` java
```
:::
### xxx 示例
::: details 代码实例解析
``` java
```
:::
## LinkedBlockingDeque
``` java
```
### xxx 代码解析
``` java
```
### xxx 函数列表
::: details 函数列表
``` java
```
:::
### xxx 示例
::: details 代码实例解析
``` java
```
:::
## LinkedTransferQueue
``` java
```
### xxx 代码解析
``` java
```
### xxx 函数列表
::: details 函数列表
``` java
```
:::
### xxx 示例
::: details 代码实例解析
``` java
```
:::
# Java基础
::: tip
本文主要对Java基础面试题进行总结。@Frank Zhao
:::
## 本章目录
[[toc]]
### 1.Java 中应该使用什么数据类型来代表价格?
* BigDecimal
   * float和double只能用来做科学计算和工程计算。
   * 商业运算中我们要使用BigDecimal。 
### 2.我们能将 int 强制转换为 byte 类型的变量吗? 
可以做强制转换<br>
但是 Java 中 int 是 32 位的，而 byte 是 8 位的，<br>
所以，如果强制转化是，int 类型的高 24 位将会被丢弃。
### 3.存在两个类，B 继承 A，C 继承 B，我们能将 B 转换为 C 么? 如 C = (C) B；
* 若子类B的创建是属于向下转型，那么可以强制类型转换
* 若子类B的创建不属于向下转型，那么不可以，会产生异常
::: details 代码实例解析
``` java
class A {
    @Override
    public String toString() {
        return "This is A";
    }
}

class B extends A {
    @Override
    public String toString() {
        return "This is B";
    }
}

class C extends B {
    @Override
    public String toString() {
        return "This is C";
    }
}

public class Test {
    public static void main(String[] args) {
        // OK
        B b1 = new C();
        C c1 = (C) b1;
        System.out.println(c1.toString());
        // ClassCastException 异常
        B b2 = new B();
        C c2 = (C) b2;
        System.out.println(c2.toString());
    }
}

运行结果：
This is C
Exception in thread "main" java.lang.ClassCastException: B cannot be cast to C
	at Test.main(Test.java:30)
```
:::
### 4.哪个类包含 clone 方法? 是 Cloneable 还是 Object?
java.lang.Cloneable 是一个标示性接口，不包含任何方法，clone 方法在 Object 类中定义。<br>
并且 clone() 方法是一个本地方法，这意味着它是由 c 或 c++ 或 其他本地语言实现的。
### 5.Java 中 ++ 操作符是线程安全的吗?
不是线程安全的操作。<br>
它涉及到多个指令，如读取变量值，增加，然后存储回内存，这个过程可能会出现多个线程交差。<br>
还会存在竞态条件（读取-修改-写入）。
### 6.a = a + b 与 a += b 的区别
如果两这个整型相加，如 byte、short 或者 int，首先会将它们提升到 int 类型，然后在执行加法操作。<br> 
但是 += 隐式的将加操作的结果类型强制转换为持有结果的类型。
``` java
byte a = 127;
byte b = 127;
// 因为 a+b 操作会将 a、b 提升为 int 类型，所以将 int 类型赋值给 byte 就会编译出错
b = a + b; // error : cannot convert from int to byte
b += a; // ok
System.out.println(b);
```
### 7.这个判断 3*0.1 == 0.3 将会返回什么? true 还是 false?
false，因为有些浮点数不能完全精确的表示出来。
### 8.怎么将 byte[] 转换为 String?
* String转byte[]格式的方法：
   * byte[] getBytes() - 用平台默认的编码方式将字符串编码为byte序列
   * byte[] getBytes(Charset charset) - 使用指定的Charset编码将字符串编码为byte序列
   * byte[] getBytes(String charsetName) - 使用字符串指定的编码方式将字符串编码为byte序列
* byte[]转String格式的方法：
   * new String(byte[] bytes) - 使用平台默认编码方式解码byte数组以构造String
   * new String(byte[] bytes, Charset charset) - 使用指定的charset方式解码byte数组以构造String
   * new String(byte[] bytes, String charsetName) - 使用String指定的方式解码byte数组以构造String
::: warning
要使用的正确的编码，否则会使用平台默认编码，可能会造成乱码
:::
::: details 代码实例解析
``` java
public static void main(String[] args) throws UnsupportedEncodingException {

    String message = "你好，这是编码测试abc";
    byte[] bytes = message.getBytes("UTF-8");
    String byteString4 = new String(bytes, "UTF-8");
    System.out.println(byteString4);

}
```
:::
### 9.String 怎么转换成 Long 类型？
各个基本类型的封装类都提供了由String转换来的方法，例如：<br>
* Long.parseLong("abc");
* Integer.parseInt("abc");
### 10.能在不进行强制转换的情况下将一个 double 值赋值给 long 类型的变量吗?
不行，不能在没有强制类型转换的前提下将一个 double 值赋值给 long 类型的变量，<br>
因为 double 类型的范围比 long 类型更广，所以必须要进行强制转换。<br>
### 11.int 和 Integer 哪个会占用更多的内存?
Integer 对象会占用更多的内存。<br>
Integer 是一个对象，需要存储对象的元数据。<br>
但是 int 是一个原始类型的数据，所以占用的空间更少。<br>
### 12.能在 Switch 中使用 String 吗?
从 Java 7 开始，我们可以在 switch case 中使用字符串，但这仅仅是一个语法糖。<br>
内部实现在 switch 中使用字符串的 hash code。<br>
### 13.Java 中的构造器链是什么?
* 当从一个构造器中调用另一个构造器时，会产生构造器链。
* 子类实例化时，会调用父类的默认无参构造方法，会产生构造器链。
::: details 代码实例解析
``` java
package com.escco.test;

public class Test2 extends Employee{
    public Test2(){
        System.out.println("(3)Performs Test2's tasks") ;
    }
    public static void main(String[] args){
        Test2 fac = new Test2();
    }
}
class Employee extends Person {
    public Employee(){
        System.out.println("(2)Performs Employee's tasks");
    }
}
class Person {
    public Person(){
        System.out.println("(1)Performs Person's tasks");
    }
}
// 运行结果：
(1)Performs Person's tasks
(2)Performs Employee's tasks
(3)Performs Test2's tasks
```
:::
### 14.有没有可能两个不相等的对象有有相同的 hashcode?
有可能，两个不相等的对象可能会有相同的 hashcode 值，这就是为什么在 hashmap 中会有冲突。<br>
相等 hashcode 值的规定只是说如果两个对象相等，必须有相同的hashcode 值，但是没有关于不相等对象的任何规定。<br>
### 15.两个相同的对象会有不同的的 hash code 吗?
不能<br>
* 根据规范，可以得到如下推论： 
   * 1、如果两个对象equals，Java运行时环境会认为他们的hashcode一定相等。 
   * 2、如果两个对象不equals，他们的hashcode有可能相等。 
   * 3、如果两个对象hashcode相等，他们不一定equals。 
   * 4、如果两个对象hashcode不相等，他们一定不equals。 
### 16.我们可以在 hashcode() 中使用随机数字吗?
不行，因为对象的 hashcode 值必须是相同的。
### 17.Java 中，Comparator 与 Comparable 有什么不同?
Comparable 接口用于定义对象的自然顺序，而 comparator 通常用于定义用户定制的顺序。<br>
Comparable 总是只有一个，但是可以有多个 comparator 来定义对象的顺序。<br>
### 18.为什么在重写 equals 方法的时候需要重写 hashCode 方法?
因为有强制的规范指定需要同时重写 hashcode 与 equal 是方法，许多容器类，如 HashMap、HashSet 都依赖于 hashcode 与 equals 的规定。
### 19.
### 20.
### 21.
### 22.
### 23.
### 24.
### 25.
### 26.
### 27.
### 28.
### 29.
### 30.
### 31.
### 32.
### 33.
### 34.
### 35.
### 36.